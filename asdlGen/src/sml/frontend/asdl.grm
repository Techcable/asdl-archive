structure T = T
fun check_first p f msg s =
    if p (String.sub(s,0)) then s
    else
	let 
	    val fixed = f s
	in
	    Error.warn [msg, "changing ",s," to ",fixed];
	    fixed
	end

val mkconid = 
	  Identifier.fromString o
	  (check_first Char.isUpper
	   (String.translate (Char.toString o Char.toUpper))
	   "Constructor must begin with an uppercase letter ")
val mktyid =
	  Identifier.fromString  o (check_first
	  Char.isLower
	  (String.translate (Char.toString o Char.toLower))
	  "Type must begin with a lowercase letter ")

type view_entry = (T.identifier list * string * string)
type view = (T.identifier * view_entry list)
    
%%
%header (functor AsdlLrValsFun(structure Token : TOKEN
   			       structure T     : ASDL))
    
%eop EOF 

(* %pos declares the type of positions for terminals.
   Each symbol has an associated left and right position. *)

%pos int

%term     LBRACK | RBRACK
	| LBRACE | RBRACE
        | LANGLE | RANGLE
        | LPAREN | RPAREN
        | QUOTE of string
        | FIELDSEP
        | DOT
        | SEQ | OPT
        | EQ
        | PIPE
        | ATTRIBUTES of string
        | MODULE  of string
        | VIEW  of string
	| ID of string
	| IMPORTS of string
	| EOF	

%nonterm  
	  asdl_type of T.asdl_type
	| asdl_type_list of T.asdl_type list 
	| constructor of T.constructor
	| constructor_list of T.constructor list 
	| field of T.field
        | field_list' of T.field list
	| field_list of T.field list 
	| id_list of T.identifier list
	| import_list of T.identifier list
        | id_opt of T.identifier option
        | id of T.identifier
        | con_id of T.identifier
        | ty_id of T.identifier
	| module of T.asdl_module	
	| module_list of T.asdl_module	list
        | start of (T.asdl_module list * view list)
        | view_list of view list
	| view of view
        | view_entity of T.identifier list
        | view_attrib of string
        | view_entity_list of T.identifier list list
        | view_av_list of (string * string) list
        | view_ev_list of (T.identifier list * string)  list
        | view_entries of view_entry list
	  
%name Asdl
%noshift EOF
%verbose
%%
(* the parser returns the value associated with the expression *)
start: module_list  view_list ((module_list,view_list))

module_list: module module_list (module::module_list)
           | (nil)

module    : MODULE id LBRACE asdl_type_list RBRACE
               ({name=id,imports=[],defs=asdl_type_list}) 
	     | MODULE id LPAREN import_list RPAREN LBRACE
	        asdl_type_list RBRACE
		({name=id,
		  imports=import_list,defs=asdl_type_list}) 

import_list : IMPORTS id import_list (id::import_list)
             | ([])
		
ty_id     : ID      (mktyid ID)
          | MODULE  (mktyid MODULE)
	  | IMPORTS (mktyid IMPORTS)
          | VIEW    (mktyid VIEW)

con_id    : ID      (mkconid ID)
          | MODULE  (mkconid MODULE)
	  | IMPORTS (mkconid IMPORTS)
		
id        : ID         (Identifier.fromString ID)
          | MODULE (Identifier.fromString MODULE)
          | IMPORTS (Identifier.fromString IMPORTS)
          | VIEW (Identifier.fromString VIEW)

id_opt    : id (SOME id)
          | (NONE)

id_list   : id    ([id])
          | id DOT id_list (id::id_list)

asdl_type : ty_id EQ constructor constructor_list 
               ATTRIBUTES LPAREN field_list' RPAREN
             (T.SumType (ty_id,field_list',constructor,constructor_list))
           | ty_id EQ constructor constructor_list
             (T.SumType (ty_id,[],constructor,constructor_list))
           | ty_id EQ LPAREN field_list'  RPAREN
	     (T.ProductType(ty_id,hd field_list', tl field_list'))

asdl_type_list: asdl_type asdl_type_list (asdl_type::asdl_type_list)
              | (nil)
 
constructor       : con_id field_list (T.Con (con_id,field_list))
constructor_list  : PIPE constructor constructor_list
                         (constructor::constructor_list)
                  | (nil)

field     :  id_list     id_opt (T.Id(id_list,id_opt))
          |  id_list OPT id_opt (T.Option(id_list,id_opt))
          |  id_list SEQ id_opt (T.Sequence(id_list,id_opt))

field_list: LPAREN field_list' RPAREN (field_list')
           | (nil)

field_list': field FIELDSEP field_list' (field::field_list')
           | field                        ([field])


(* hacked ugly syntax for now *)



view     : VIEW id LBRACE view_entries RBRACE ((id,view_entries))
view_entity : id DOT id_list (id::id_list)
            | MODULE id      ([id])

view_attrib : LANGLE EQ ID (ID)

view_entity_list : view_entity view_entity_list (view_entity::view_entity_list)
                 | (nil)

view_av_list : ID QUOTE view_av_list 
                 ((ID,QUOTE)::view_av_list)
             | (nil)

view_ev_list : view_entity QUOTE view_ev_list
		 ((view_entity,QUOTE)::view_ev_list)
             | (nil)

view_entries: view_entity view_attrib QUOTE view_entries
                          ((view_entity,view_attrib,QUOTE)::view_entries)

	    | LBRACE view_entity_list RBRACE view_attrib QUOTE view_entries
	      (List.foldr (fn (x,xs) => (x,view_attrib,QUOTE)::xs)
	       view_entries view_entity_list)

	    | view_attrib LBRACE view_ev_list RBRACE view_entries
	      (List.foldr (fn ((e,v),xs) => (e,view_attrib,v)::xs)
	       view_entries view_ev_list)

	    | view_entity LANGLE EQ LBRACE view_av_list RBRACE view_entries
	      (List.foldr (fn ((a,v),xs) => (view_entity,a,v)::xs)
	       view_entries view_av_list)
	    | (nil)

	      
view_list: view view_list (view::view_list)
         | (nil)

