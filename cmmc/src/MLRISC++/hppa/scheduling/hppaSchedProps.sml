(*
 * This file was automatically generated by MDGen (v2.0)
 * from the machine description file "hppa/hppa.md".
 *)


functor HppaSchedProps(structure Instr : HPPAINSTR
                       structure RegionProps : REGION_PROPERTIES
                       structure Asm   : INSTRUCTION_EMITTER where I = Instr
                         sharing RegionProps.Region = Instr.Region
                      ) : SCHEDULING_PROPERTIES =
struct
   structure I = Instr
   structure C = I.C
   
   type latency = int
   type time = int
   type architecture = string
   
   exception HppaStructuralHazard
   exception StructuralHazard = HppaStructuralHazard
   fun error msg = MLRiscErrorMsg.error("HppaSchedProps",msg)
   
   fun bug(msg,instr) =
   let val Asm.S.STREAM{emit, ...} = Asm.makeStream []
   in  emit (fn r => r) instr; error msg end
   
   val source = I.SOURCE{}
   val sink   = I.SINK{}
   
   structure A = DynArray
   type state = int
   type reservation_table = (state * I.instruction list) A.array
   fun newTableDefault{n, backward} = A.array(n,(0,[]))
   fun defUseDefault instr = let
          fun undefined () = bug ("defUseDefault", instr)
          fun getOpnd (opnd, rest) = rest
          fun mkSet set = map (fn r => (r,0)) set
          fun getRegionDef r = 
          let val (d,u) = RegionProps.writeTo r
          in  map (fn r => (r,~1)) d end
          fun getRegionUse r = RegionProps.readFrom r
          fun getCellSetDef (GP, FP) = (mkSet GP) @ (mkSet FP)
          fun getCellSetUse (GP, FP) = GP @ FP
          fun query (I.LOADI{li, r, i, t, mem}) = ([(t, 1)], getOpnd (i, r::(getRegionUse mem)))
            | query (I.LOAD{l, r1, r2, t, mem}) = 
              (
               case l of
               (I.LDWX | I.LDWX_S | I.LDHX | I.LDHX_S | I.LDBX) => ([(t, 1)], r1::r2::(getRegionUse mem))
             | (I.LDWX_M | I.LDWX_SM | I.LDHX_M | I.LDHX_SM | I.LDBX_M) => ([(r1, 1), (t, 1)], r1::r2::(getRegionUse mem))
              )
            | query (I.STORE{st, b, d, r, mem}) = (getRegionDef mem, getOpnd (d, [b, r]))
            | query (I.ARITH{a, r1, r2, t}) = ([(t, 0)], [r1, r2])
            | query (I.ARITHI{ai, i, r, t}) = ([(t, 0)], getOpnd (i, [r]))
            | query (I.COMCLR_LDO{cc, r1, r2, t1, i, b, t2}) = (if (t1 = t2)
                 then ([(t1, 0)], [b, r1, r2])
                 else (if (t1 = 0)
                    then ([(t2, 0)], [b, r1, r2, t2])
                    else ([(t1, 0), (t2, 0)], [b, r1, r2, t1, t2])))
            | query (I.COMICLR_LDO{cc, i1, r2, t1, i2, b, t2}) = (if (t1 = t2)
                 then ([(t1, 0)], getOpnd (i1, [b, r2]))
                 else (if (t1 = 0)
                    then ([(t2, 0)], getOpnd (i1, [b, r2, t2]))
                    else ([(t1, 0), (t2, 0)], getOpnd (i1, [b, r2, t1, t2]))))
            | query (I.SHIFTV{sv, r, len, t}) = ([(t, 0)], [r, 75])
            | query (I.SHIFT{s, r, p, len, t}) = ([(t, 0)], [r])
            | query (I.BCOND{cmp, bc, r1, r2, n, nop, t, f}) = ([(96, 0)], [r1, r2])
            | query (I.BCONDI{cmpi, bc, i, r2, n, nop, t, f}) = ([(96, 0)], [r2])
            | query (I.BB{bc, r, p, n, nop, t, f}) = ([(96, 0)], [r])
            | query (I.B{lab, n}) = ([], [])
            | query (I.LONGJUMP{lab, n, tmp, tmpLab}) = ([], [])
            | query (I.BV{x, b, labs, n}) = ([], [b, x])
            | query (I.BLE{d, b, sr, t, defs, uses, mem}) = ((31, 0)::((getCellSetDef defs) @ (getRegionDef mem)), getOpnd (d, b::((getCellSetUse uses) @ (getRegionUse mem))))
            | query (I.LDIL{i, t}) = ([(t, 0)], getOpnd (i, []))
            | query (I.LDO{i, b, t}) = (if (b = 0)
                 then ([(t, 0)], getOpnd (i, []))
                 else ([(t, 0)], getOpnd (i, [b])))
            | query (I.MTCTL{r, t}) = ([(t, 0)], [r])
            | query (I.FSTORE{fst, b, d, r, mem}) = (getRegionDef mem, [b, r])
            | query (I.FSTOREX{fstx, b, x, r, mem}) = 
              (
               case fstx of
               (I.FSTDX | I.FSTDX_S | I.FSTWX | I.FSTWX_S) => (getRegionDef mem, [b, r, x])
             | (I.FSTDX_M | I.FSTDX_SM | I.FSTWX_M | I.FSTWX_SM) => ((b, 0)::(getRegionDef mem), [b, r, x])
              )
            | query (I.FLOAD{fl, b, d, t, mem}) = ([(t, 1)], b::(getRegionUse mem))
            | query (I.FLOADX{flx, b, x, t, mem}) = 
              (
               case flx of
               (I.FLDDX | I.FLDDX_S | I.FLDWX | I.FLDWX_S) => ([(t, 1)], b::x::(getRegionUse mem))
             | (I.FLDDX_M | I.FLDDX_SM | I.FLDWX_M | I.FLDWX_SM) => ([(b, 1), (t, 1)], b::x::(getRegionUse mem))
              )
            | query (I.FARITH{fa, r1, r2, t}) = ([(t, 1)], [r1, r2])
            | query (I.FUNARY{fu, f, t}) = ([(t, 0)], [f])
            | query (I.FCNV{fcnv, f, t}) = ([(t, 0)], [f])
            | query (I.FBRANCH{cc, fmt, f1, f2, t, f, n, long}) = 
              (
               case cc of
               
               ( I.? |
               I.!<=> |
               I.== |
               I.?= |
               I.!<> |
               I.!?>= |
               I.< |
               I.?< |
               I.!>= |
               I.!?> |
               I.<= |
               I.?<= |
               I.!> |
               I.!?<= |
               I.> |
               I.?> |
               I.!<= |
               I.!?< |
               I.>= |
               I.?>= |
               I.!< |
               I.!?= |
               I.<> |
               I.!= |
               I.!? |
               I.<=> ) => ([], [f1, f2])
             | (I.False_ | I.False | I.EQT | I.NET | I.True_ | I.True) => undefined ()
              )
            | query (I.NOP) = ([], [])
            | query (I.COPY{dst, src, impl, tmp}) = (mkSet dst, src)
            | query (I.FCOPY{dst, src, impl, tmp}) = (mkSet dst, src)
            | query (I.ANNOTATION{i, a}) = query i
            | query _ = undefined ()
       in query instr
       end

   fun insertAfterDefault(rt, time, instr) = 
   let fun loop(t) = 
       let val (state, _) = A.sub(rt, t)
       in  if state >= 1 then loop(t+1) else t (* XXX *)
       end
       val index = loop(time)
       val (state, instrs) = A.sub(rt, index)
       val newState = state+1
       val newInstrs = instr::instrs
   in  A.update(rt, index, (newState, newInstrs)); time end
   fun insertBeforeDefault(rt, time, instr) = 
   let val index = ~time
       val (state, instrs) = A.sub(rt, index)
       val newState = state
       val newInstrs = instr::instrs
   in  A.update(rt, index, (newState, newInstrs)); time end
   fun linearizeDefault{table, backward} = 
     if backward then
        A.foldr (fn ((_,instrs),l) => List.revAppend(instrs,l)) [] table
     else
        A.foldl (fn ((_,instrs),l) => instrs @ l) [] table
   fun info arch = {newTable=newTableDefault, defUse=defUseDefault, insertAfter=insertAfterDefault, insertBefore=insertBeforeDefault, linearize=linearizeDefault}
   structure Shuffle = Shuffle(I)
   fun move{src=I.Direct rs,dst=I.Direct rd} =
        [I.COPY{src=[rs], dst=[rd], tmp=NONE, impl=ref NONE}]
   fun fmove{src=I.FDirect rs,dst=I.FDirect rd} =
        [I.FCOPY{src=[rs], dst=[rd], tmp=NONE, impl=ref NONE}]
   val shuffle = Shuffle.shuffle{mvInstr=move, ea=I.Direct}
   val shufflefp = Shuffle.shuffle{mvInstr=fmove, ea=I.FDirect}
   fun splitCopies regmap =
   let fun f(I.ANNOTATION{i,...}) = f i
         | f(I.COPY{src,dst,tmp,...}) =
             shuffle{regmap=regmap, tmp=tmp, src=src, dst=dst}
         | f(I.FCOPY{src,dst,tmp,...}) =
             shufflefp{regmap=regmap, tmp=tmp, src=src, dst=dst}
         | f i = [i]
   in  f end
end

