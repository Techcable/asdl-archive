(*
 * This file was automatically generated by MDGen (v2.0)
 * from the machine description file "hppa/hppa.md".
 *)


functor HppaSSAProps(structure Instr : HPPAINSTR
                     structure RegionProps : REGION_PROPERTIES 
                     structure RTLProps : RTL_PROPERTIES where I = Instr
                     structure Asm : INSTRUCTION_EMITTER where I = Instr
                     structure OperandTable : OPERAND_TABLE where I = Instr
                       sharing RegionProps.Region = Instr.Region
                     val volatile : Instr.C.cell list
                     val pinnedDef  : Instr.C.cell list
                     val pinnedUse  : Instr.C.cell list
                     val fixedDef   : Instr.C.cell list
                     val fixedUse   : Instr.C.cell list
                    ) : SSA_PROPERTIES =
struct
   structure I        = Instr
   structure C        = I.C
   structure RTLProps = RTLProps
   structure RTL      = RTLProps.RTL
   structure T        = RTL.T
   structure OT       = OperandTable
   structure RP       = RegionProps
   
   datatype const = datatype OT.const
   
   fun error msg = MLRiscErrorMsg.error("HppaSSAProps",msg)
   
   fun bug(msg,instr) =
   let val Asm.S.STREAM{emit, ...} = Asm.makeStream []
   in  emit (fn r => r) instr; error msg end
   
   val volatile = volatile
   val pinnedDef = pinnedDef
   val pinnedUse = pinnedUse
   val fixedDef  = fixedDef
   val fixedUse  = fixedUse
   val source = I.SOURCE{}
   val sink   = I.SINK{}
   val phi    = I.PHI{}
   
   fun namingConstraints {instr, dst, src} = let
          fun undefined () = bug ("namingConstraints", instr)
          fun cellset(dstsrc,S,C) =
          let val S = C.cellsetToCells S
          in  List.revAppend(ListPair.zip(dstsrc,S),C) end
          fun query (I.LOADI{li, r, i, t, mem}) = {dst=[], src=[], dstsrc=[]}
            | query (I.LOAD{l, r1, r2, t, mem}) = {dst=[], src=[], dstsrc=[]}
            | query (I.STORE{st, b, d, r, mem}) = {dst=[], src=[], dstsrc=[]}
            | query (I.ARITH{a, r1, r2, t}) = {dst=[], src=[], dstsrc=[]}
            | query (I.ARITHI{ai, i, r, t}) = {dst=[], src=[], dstsrc=[]}
            | query (I.COMCLR_LDO{cc, r1, r2, t1, i, b, t2}) = {dst=[], src=[], dstsrc=[]}
            | query (I.COMICLR_LDO{cc, i1, r2, t1, i2, b, t2}) = {dst=[], src=[], dstsrc=[]}
            | query (I.SHIFTV{sv, r, len, t}) = 
              (
               case (sv, dst, src) of
               (_, _, [_, _, r75src]) => {dst=[], src=[(r75src, 75)], dstsrc=[]}
              )
            | query (I.SHIFT{s, r, p, len, t}) = {dst=[], src=[], dstsrc=[]}
            | query (I.BCOND{cmp, bc, r1, r2, n, nop, t, f}) = {dst=[], src=[], dstsrc=[]}
            | query (I.BCONDI{cmpi, bc, i, r2, n, nop, t, f}) = {dst=[], src=[], dstsrc=[]}
            | query (I.BB{bc, r, p, n, nop, t, f}) = {dst=[], src=[], dstsrc=[]}
            | query (I.B{lab, n}) = {dst=[], src=[], dstsrc=[]}
            | query (I.LONGJUMP{lab, n, tmp, tmpLab}) = {dst=[], src=[], dstsrc=[]}
            | query (I.BV{x, b, labs, n}) = {dst=[], src=[], dstsrc=[]}
            | query (I.BLE{d, b, sr, t, defs, uses, mem}) = 
              (
               case ((), dst, src) of
               ((), r31dst::defsdst, _::_::usessrc) => {dst=cellset (defsdst, defs, [(r31dst, 31)]), src=cellset (usessrc, uses, []), dstsrc=[]}
              )
            | query (I.LDIL{i, t}) = {dst=[], src=[], dstsrc=[]}
            | query (I.LDO{i, b, t}) = {dst=[], src=[], dstsrc=[]}
            | query (I.MTCTL{r, t}) = {dst=[], src=[], dstsrc=[]}
            | query (I.FSTORE{fst, b, d, r, mem}) = {dst=[], src=[], dstsrc=[]}
            | query (I.FSTOREX{fstx, b, x, r, mem}) = {dst=[], src=[], dstsrc=[]}
            | query (I.FLOAD{fl, b, d, t, mem}) = {dst=[], src=[], dstsrc=[]}
            | query (I.FLOADX{flx, b, x, t, mem}) = {dst=[], src=[], dstsrc=[]}
            | query (I.FARITH{fa, r1, r2, t}) = {dst=[], src=[], dstsrc=[]}
            | query (I.FUNARY{fu, f, t}) = {dst=[], src=[], dstsrc=[]}
            | query (I.FCNV{fcnv, f, t}) = {dst=[], src=[], dstsrc=[]}
            | query (I.FBRANCH{cc, fmt, f1, f2, t, f, n, long}) = 
              (
               case (cc, dst, src) of
               (
               ( I.? |
               I.!<=> |
               I.== |
               I.?= |
               I.!<> |
               I.!?>= |
               I.< |
               I.?< |
               I.!>= |
               I.!?> |
               I.<= |
               I.?<= |
               I.!> |
               I.!?<= |
               I.> |
               I.?> |
               I.!<= |
               I.!?< |
               I.>= |
               I.?>= |
               I.!< |
               I.!?= |
               I.<> |
               I.!= |
               I.!? |
               I.<=> ), _, _) => {dst=[], src=[], dstsrc=[]}
             | ((I.False_ | I.False | I.EQT | I.NET | I.True_ | I.True), _, _) => undefined ()
              )
            | query (I.NOP) = {dst=[], src=[], dstsrc=[]}
            | query (I.COPY{dst, src, impl, tmp}) = {dst=[], src=[], dstsrc=[]}
            | query (I.FCOPY{dst, src, impl, tmp}) = {dst=[], src=[], dstsrc=[]}
            | query (I.ANNOTATION{i, a}) = query i
            | query _ = undefined ()
       in query instr
       end

   fun rewriteOperands {const} {instr, dst, src} = let
          fun undefined () = bug ("rewriteOperands", instr)
          fun rwOpnd v =
          if v >= 0 then error "rwOpnd"(v)
          else (case const v of
                 OT.OPERAND opnd => opnd
               | OT.IMMED i => I.IMMED(i)
               )
          fun query (I.LOADI{li, r, i, t, mem}) = 
              (
               case (li, dst, src) of
               (_, [t'], i''::r''::_) => I.LOADI {li=li, r=r'', i=rwOpnd i'', t=t', mem=mem}
              )
            | query (I.LOAD{l, r1, r2, t, mem}) = 
              (
               case (l, dst, src) of
               ((I.LDWX | I.LDWX_S | I.LDHX | I.LDHX_S | I.LDBX), [t'], r1''::r2''::_) => I.LOAD {l=l, r1=r1'', r2=r2'', t=t', mem=mem}
             | ((I.LDWX_M | I.LDWX_SM | I.LDHX_M | I.LDHX_SM | I.LDBX_M), [r1', t'], r1''::r2''::_) => I.LOAD {l=l, r1=r1', r2=r2'', t=t', mem=mem}
              )
            | query (I.STORE{st, b, d, r, mem}) = 
              (
               case (st, dst, src) of
               (_, _, [d'', b'', r'']) => I.STORE {st=st, b=b'', d=rwOpnd d'', r=r'', mem=mem}
              )
            | query (I.ARITH{a, r1, r2, t}) = 
              (
               case (a, dst, src) of
               (_, [t'], [r1'', r2'']) => I.ARITH {a=a, r1=r1'', r2=r2'', t=t'}
              )
            | query (I.ARITHI{ai, i, r, t}) = 
              (
               case (ai, dst, src) of
               (_, [t'], [i'', r'']) => I.ARITHI {ai=ai, i=rwOpnd i'', r=r'', t=t'}
              )
            | query (I.COMCLR_LDO{cc, r1, r2, t1, i, b, t2}) = (if (t1 = t2)
                 then 
                 (
                  case (cc, dst, src) of
                  (_, [t1'], [_, b'', r1'', r2'']) => I.COMCLR_LDO {cc=cc, r1=r1'', r2=r2'', t1=t1', i=i, b=b'', t2=t2}
                 )
                 else (if (t1 = 0)
                    then 
                    (
                     case (cc, dst, src) of
                     (_, [t2'], [_, b'', r1'', r2'', t2'']) => I.COMCLR_LDO {cc=cc, r1=r1'', r2=r2'', t1=t1, i=i, b=b'', t2=t2'}
                    )
                    else 
                    (
                     case (cc, dst, src) of
                     (_, [t1', t2'], [_, b'', r1'', r2'', t1'', t2'']) => I.COMCLR_LDO {cc=cc, r1=r1'', r2=r2'', t1=t1', i=i, b=b'', t2=t2'}
                    )))
            | query (I.COMICLR_LDO{cc, i1, r2, t1, i2, b, t2}) = (if (t1 = t2)
                 then 
                 (
                  case (cc, dst, src) of
                  (_, [t1'], [i1'', _, b'', r2'']) => I.COMICLR_LDO {cc=cc, i1=rwOpnd i1'', r2=r2'', t1=t1', i2=i2, b=b'', t2=t2}
                 )
                 else (if (t1 = 0)
                    then 
                    (
                     case (cc, dst, src) of
                     (_, [t2'], [i1'', _, b'', r2'', t2'']) => I.COMICLR_LDO {cc=cc, i1=rwOpnd i1'', r2=r2'', t1=t1, i2=i2, b=b'', t2=t2'}
                    )
                    else 
                    (
                     case (cc, dst, src) of
                     (_, [t1', t2'], [i1'', _, b'', r2'', t1'', t2'']) => I.COMICLR_LDO {cc=cc, i1=rwOpnd i1'', r2=r2'', t1=t1', i2=i2, b=b'', t2=t2'}
                    )))
            | query (I.SHIFTV{sv, r, len, t}) = 
              (
               case (sv, dst, src) of
               (_, [t'], [_, r'', _]) => I.SHIFTV {sv=sv, r=r'', len=len, t=t'}
              )
            | query (I.SHIFT{s, r, p, len, t}) = 
              (
               case (s, dst, src) of
               (_, [t'], [_, _, r'']) => I.SHIFT {s=s, r=r'', p=p, len=len, t=t'}
              )
            | query (I.BCOND{cmp, bc, r1, r2, n, nop, t, f}) = 
              (
               case ((cmp, bc), dst, src) of
               (_, [_], [r1'', r2'']) => I.BCOND {cmp=cmp, bc=bc, r1=r1'', r2=r2'', n=n, nop=nop, t=t, f=f}
              )
            | query (I.BCONDI{cmpi, bc, i, r2, n, nop, t, f}) = 
              (
               case ((cmpi, bc), dst, src) of
               (_, [_], [_, r2'']) => I.BCONDI {cmpi=cmpi, bc=bc, i=i, r2=r2'', n=n, nop=nop, t=t, f=f}
              )
            | query (I.BB{bc, r, p, n, nop, t, f}) = 
              (
               case (bc, dst, src) of
               (_, [_], [_, r'']) => I.BB {bc=bc, r=r'', p=p, n=n, nop=nop, t=t, f=f}
              )
            | query (I.B{lab, n}) = I.B {lab=lab, n=n}
            | query (I.LONGJUMP{lab, n, tmp, tmpLab}) = I.LONGJUMP {lab=lab, n=n, tmp=tmp, tmpLab=tmpLab}
            | query (I.BV{x, b, labs, n}) = 
              (
               case ((), dst, src) of
               ((), [], [b'', x'']) => I.BV {x=x'', b=b'', labs=labs, n=n}
              )
            | query (I.BLE{d, b, sr, t, defs, uses, mem}) = 
              (
               case ((), dst, src) of
               ((), _, d''::b''::_) => I.BLE {d=rwOpnd d'', b=b'', sr=sr, t=t, defs=defs, uses=uses, mem=mem}
              )
            | query (I.LDIL{i, t}) = 
              (
               case ((), dst, src) of
               ((), [t'], [i'']) => I.LDIL {i=rwOpnd i'', t=t'}
              )
            | query (I.LDO{i, b, t}) = (if (b = 0)
                 then 
                 (
                  case ((), dst, src) of
                  ((), [t'], [i'']) => I.LDO {i=rwOpnd i'', b=b, t=t'}
                 )
                 else 
                 (
                  case ((), dst, src) of
                  ((), [t'], [i'', b'']) => I.LDO {i=rwOpnd i'', b=b'', t=t'}
                 ))
            | query (I.MTCTL{r, t}) = 
              (
               case ((), dst, src) of
               ((), [t'], [r'']) => I.MTCTL {r=r'', t=t'}
              )
            | query (I.FSTORE{fst, b, d, r, mem}) = 
              (
               case (fst, dst, src) of
               (_, _, [_, b'', r'']) => I.FSTORE {fst=fst, b=b'', d=d, r=r'', mem=mem}
              )
            | query (I.FSTOREX{fstx, b, x, r, mem}) = 
              (
               case (fstx, dst, src) of
               ((I.FSTDX | I.FSTDX_S | I.FSTWX | I.FSTWX_S), _, [b'', r'', x'']) => I.FSTOREX {fstx=fstx, b=b'', x=x'', r=r'', mem=mem}
             | ((I.FSTDX_M | I.FSTDX_SM | I.FSTWX_M | I.FSTWX_SM), b'::_, [b'', r'', x'']) => I.FSTOREX {fstx=fstx, b=b', x=x'', r=r'', mem=mem}
              )
            | query (I.FLOAD{fl, b, d, t, mem}) = 
              (
               case (fl, dst, src) of
               (_, [t'], _::b''::_) => I.FLOAD {fl=fl, b=b'', d=d, t=t', mem=mem}
              )
            | query (I.FLOADX{flx, b, x, t, mem}) = 
              (
               case (flx, dst, src) of
               ((I.FLDDX | I.FLDDX_S | I.FLDWX | I.FLDWX_S), [t'], b''::x''::_) => I.FLOADX {flx=flx, b=b'', x=x'', t=t', mem=mem}
             | ((I.FLDDX_M | I.FLDDX_SM | I.FLDWX_M | I.FLDWX_SM), [b', t'], b''::x''::_) => I.FLOADX {flx=flx, b=b', x=x'', t=t', mem=mem}
              )
            | query (I.FARITH{fa, r1, r2, t}) = 
              (
               case (fa, dst, src) of
               (_, [t'], [r1'', r2'']) => I.FARITH {fa=fa, r1=r1'', r2=r2'', t=t'}
              )
            | query (I.FUNARY{fu, f, t}) = 
              (
               case (fu, dst, src) of
               (_, [t'], [f'']) => I.FUNARY {fu=fu, f=f'', t=t'}
              )
            | query (I.FCNV{fcnv, f, t}) = 
              (
               case (fcnv, dst, src) of
               (_, [t'], [f'']) => I.FCNV {fcnv=fcnv, f=f'', t=t'}
              )
            | query (I.FBRANCH{cc, fmt, f1, f2, t, f, n, long}) = 
              (
               case (cc, dst, src) of
               (
               ( I.? |
               I.!<=> |
               I.== |
               I.?= |
               I.!<> |
               I.!?>= |
               I.< |
               I.?< |
               I.!>= |
               I.!?> |
               I.<= |
               I.?<= |
               I.!> |
               I.!?<= |
               I.> |
               I.?> |
               I.!<= |
               I.!?< |
               I.>= |
               I.?>= |
               I.!< |
               I.!?= |
               I.<> |
               I.!= |
               I.!? |
               I.<=> ), [], [f1'', f2'']) => I.FBRANCH {cc=cc, fmt=fmt, f1=f1'', f2=f2'', t=t, f=f, n=n, long=long}
             | ((I.False_ | I.False | I.EQT | I.NET | I.True_ | I.True), _, _) => undefined ()
              )
            | query (I.NOP) = I.NOP 
            | query (I.COPY{dst, src, impl, tmp}) = I.COPY {dst=dst, src=src, impl=impl, tmp=tmp}
            | query (I.FCOPY{dst, src, impl, tmp}) = I.FCOPY {dst=dst, src=src, impl=impl, tmp=tmp}
            | query (I.ANNOTATION{i, a}) = I.ANNOTATION {i=query i, a=a}
            | query _ = undefined ()
       in query instr
       end

   fun copies cps =
   let fun f([],id,is,fd,fs) = (id,is,fd,fs)
         | f({kind,dst,src}::cps,id,is,fd,fs) =
           if dst=src then f(cps,id,is,fd,fs)
           else case kind of
                C.GP   => f(cps,dst::id,src::is,fd,fs)
             |  C.FP   => f(cps,id,is,dst::fd,src::fs)
             |  C.MEM  => f(cps,id,is,fd,fs)
             |  C.CTRL => f(cps,id,is,fd,fs)
             |  _      => error("copies: "^C.cellkindToString kind^
                                " dst="^C.toString kind dst^
                                " src="^C.toString kind src)
    val (id,is,fd,fs) = f(cps,[],[],[],[])
    val icopy = case id of
                  []  => []
                | [_] => [I.COPY{src=is,dst=id,impl=ref NONE,tmp=NONE}]
                | _   => [I.COPY{src=is,dst=id,impl=ref NONE,
                                 tmp=SOME(I.Direct(C.newReg()))}]
    val fcopy = case fd of
                  []  => []
                | [_] => [I.FCOPY{src=fs,dst=fd,impl=ref NONE,tmp=NONE}]
                | _   => [I.FCOPY{src=fs,dst=fd,impl=ref NONE,
                                  tmp=SOME(I.FDirect(C.newFreg()))}]
   in icopy @ fcopy end
   
   fun copy{instr=I.COPY{impl,tmp,...},dst=dst as [_],src} =
           I.COPY{impl=impl,tmp=NONE,dst=dst,src=src}
     | copy{instr=I.COPY{impl,tmp,...},dst,src} =
           I.COPY{impl=impl,tmp=tmp,dst=dst,src=src}
     | copy{instr=I.FCOPY{impl,tmp,...},dst=dst as [_],src} =
           I.FCOPY{impl=impl,tmp=NONE,dst=dst,src=src}
     | copy{instr=I.FCOPY{impl,tmp,...},dst,src} =
           I.FCOPY{impl=impl,tmp=tmp,dst=dst,src=src}
     | copy{instr=I.ANNOTATION{i,a},dst,src} =
           I.ANNOTATION{i=copy{instr=i,dst=dst,src=src},a=a}
     | copy{instr,...} = bug("copy",instr)

(*#line 1070.7 "hppa/hppa.md"*)
   fun operand (ty, I.REG r) = T.REG (ty, r)
     | operand (ty, I.IMMED i) = T.LI i
     | operand _ = error "operand"
end

