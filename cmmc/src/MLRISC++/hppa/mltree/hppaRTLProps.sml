(*
 * This file was automatically generated by MDGen (v2.0)
 * from the machine description file "hppa/hppa.md".
 *)


functor HppaRTLProps(structure Instr : HPPAINSTR
                     structure RegionProps : REGION_PROPERTIES
                     structure Asm : INSTRUCTION_EMITTER where I = Instr
                       sharing Instr.Region = RegionProps.Region
                    ) : RTL_PROPERTIES =
struct
   structure I   = Instr
   structure C   = I.C
   structure RTL = MLTreeRTL
   structure T   = RTL.T
   
   datatype opnkind =
     IMM     (* a constant operand *)
   | REG     (* can be renamed *)
   | FIX     (* cannot be renamed *)
   | MEM     (* memory *)
   | CTRL    (* control dependence *)
   
   fun error msg = MLRiscErrorMsg.error("HppaRTLProps",msg)
   
   fun bug(msg,instr) =
   let val Asm.S.STREAM{emit, ...} = Asm.makeStream []
   in  emit (fn r => r) instr; error msg end
   
   structure HppaRTL = HppaRTL(BuildRTL)
   structure Arch = struct
      local
         val TMP0 = T.REG (32, 0)
         val TMP1 = T.REG (64, 0)
         val TMP2 = T.REG (32, 1)
         val TMP3 = T.REG (0, 2)
         val TMP4 = T.REXT (32, RTL.PARAM (0, 0))
         val TMP5 = T.REG (32, 2)
         val TMP6 = T.REG (0, 0)
         val TMP7 = T.REG (32, 3)
         val TMP8 = T.REXT (32, RTL.PARAM (0, 4))
         val TMP9 = T.REXT (32, RTL.PARAM (1, 5))
         val TMP10 = T.REG (0, 1)
         val TMP11 = T.REXT (0, RTL.PARAM (2, 3))
         val TMP12 = T.REG (64, 1)
         val TMP13 = T.REG (64, 2)
      in
         val NOP = RTL.new (HppaRTL.NOP {})
         val COPY = RTL.new (HppaRTL.COPY {dst=TMP0, src=TMP0})
         val FCOPY = RTL.new (HppaRTL.FCOPY {dst=TMP1, src=TMP1})
         val LDO = RTL.new (HppaRTL.LDO {b=TMP2, i=TMP0, t=TMP0})
         val LDO2 = RTL.new (HppaRTL.LDO2 {i=TMP0, t=TMP0})
         val LDIL = RTL.new (HppaRTL.LDIL {i=TMP0, t=TMP0})
         val MTCTL = RTL.new (HppaRTL.MTCTL {r=TMP0, t=TMP0})
         val LDW = RTL.new (HppaRTL.LDW {r=TMP2, i=TMP0, t=TMP0, mem=TMP3})
         val LDH = RTL.new (HppaRTL.LDH {r=TMP2, i=TMP0, t=TMP0, mem=TMP3})
         val LDB = RTL.new (HppaRTL.LDB {r=TMP2, i=TMP0, t=TMP0, mem=TMP3})
         val LDWX = RTL.new (HppaRTL.LDWX {r1=TMP0, r2=TMP2, t=TMP0, mem=TMP3})
         val LDWX_S = RTL.new (HppaRTL.LDWX_S {r1=TMP0, r2=TMP2, t=TMP0, mem=TMP3})
         val LDWX_M = RTL.new (HppaRTL.LDWX_M {r1=TMP4, r2=TMP2, t=TMP2, mem=TMP3})
         val LDWX_SM = RTL.new (HppaRTL.LDWX_SM {r1=TMP4, r2=TMP2, t=TMP2, mem=TMP3})
         val LDHX = RTL.new (HppaRTL.LDHX {r1=TMP0, r2=TMP2, t=TMP0, mem=TMP3})
         val LDHX_S = RTL.new (HppaRTL.LDHX_S {r1=TMP0, r2=TMP2, t=TMP0, mem=TMP3})
         val LDHX_M = RTL.new (HppaRTL.LDHX_M {r1=TMP4, r2=TMP2, t=TMP2, mem=TMP3})
         val LDHX_SM = RTL.new (HppaRTL.LDHX_SM {r1=TMP4, r2=TMP2, t=TMP2, mem=TMP3})
         val LDBX = RTL.new (HppaRTL.LDBX {r1=TMP0, r2=TMP2, t=TMP0, mem=TMP3})
         val LDBX_M = RTL.new (HppaRTL.LDBX_M {r1=TMP4, r2=TMP2, t=TMP2, mem=TMP3})
         val STW = RTL.new (HppaRTL.STW {b=TMP2, d=TMP0, r=TMP5, mem=TMP6})
         val STH = RTL.new (HppaRTL.STH {b=TMP2, d=TMP0, r=TMP5, mem=TMP6})
         val STB = RTL.new (HppaRTL.STB {b=TMP2, d=TMP0, r=TMP5, mem=TMP6})
         val ADD = RTL.new (HppaRTL.ADD {r1=TMP0, r2=TMP2, t=TMP0})
         val ADDL = RTL.new (HppaRTL.ADDL {r1=TMP0, r2=TMP2, t=TMP0})
         val ADDO = RTL.new (HppaRTL.ADDO {r1=TMP0, r2=TMP2, t=TMP0})
         val SUB = RTL.new (HppaRTL.SUB {r1=TMP0, r2=TMP2, t=TMP0})
         val SUBO = RTL.new (HppaRTL.SUBO {r1=TMP0, r2=TMP2, t=TMP0})
         val SH1ADD = RTL.new (HppaRTL.SH1ADD {r1=TMP0, r2=TMP2, t=TMP0})
         val SH2ADD = RTL.new (HppaRTL.SH2ADD {r1=TMP0, r2=TMP2, t=TMP0})
         val SH3ADD = RTL.new (HppaRTL.SH3ADD {r1=TMP0, r2=TMP2, t=TMP0})
         val SH1ADDL = RTL.new (HppaRTL.SH1ADDL {r1=TMP0, r2=TMP2, t=TMP0})
         val SH2ADDL = RTL.new (HppaRTL.SH2ADDL {r1=TMP0, r2=TMP2, t=TMP0})
         val SH3ADDL = RTL.new (HppaRTL.SH3ADDL {r1=TMP0, r2=TMP2, t=TMP0})
         val SH1ADDO = RTL.new (HppaRTL.SH1ADDO {r1=TMP0, r2=TMP2, t=TMP0})
         val SH2ADDO = RTL.new (HppaRTL.SH2ADDO {r1=TMP0, r2=TMP2, t=TMP0})
         val SH3ADDO = RTL.new (HppaRTL.SH3ADDO {r1=TMP0, r2=TMP2, t=TMP0})
         val OR = RTL.new (HppaRTL.OR {r1=TMP0, r2=TMP2, t=TMP0})
         val AND = RTL.new (HppaRTL.AND {r1=TMP0, r2=TMP2, t=TMP0})
         val XOR = RTL.new (HppaRTL.XOR {r1=TMP0, r2=TMP2, t=TMP0})
         val ANDCM = RTL.new (HppaRTL.ANDCM {r1=TMP0, r2=TMP2, t=TMP0})
         val ADDI = RTL.new (HppaRTL.ADDI {r=TMP2, i=TMP0, t=TMP0})
         val ADDIO = RTL.new (HppaRTL.ADDIO {r=TMP2, i=TMP0, t=TMP0})
         val ADDIL = RTL.new (HppaRTL.ADDIL {r=TMP2, i=TMP0, t=TMP0})
         val SUBI = RTL.new (HppaRTL.SUBI {r=TMP2, i=TMP0, t=TMP0})
         val SUBIO = RTL.new (HppaRTL.SUBIO {r=TMP2, i=TMP0, t=TMP0})
         val VEXTRU = RTL.new (HppaRTL.VEXTRU {r=TMP2, len=TMP0, t=TMP0})
         val VEXTRS = RTL.new (HppaRTL.VEXTRS {r=TMP2, len=TMP0, t=TMP0})
         val ZVDEP = RTL.new (HppaRTL.ZVDEP {r=TMP2, len=TMP0, t=TMP0})
         val EXTRU = RTL.new (HppaRTL.EXTRU {r=TMP5, p=TMP2, len=TMP0, t=TMP0})
         val EXTRS = RTL.new (HppaRTL.EXTRS {r=TMP5, p=TMP2, len=TMP0, t=TMP0})
         val ZDEP = RTL.new (HppaRTL.ZDEP {r=TMP5, p=TMP2, len=TMP0, t=TMP0})
         val COMCLR_LDO_EQ = RTL.new (HppaRTL.COMCLR_LDO_EQ {r1=TMP5, r2=TMP7, t1=TMP8, i=TMP0, b=TMP2, t2=TMP9})
         val COMCLR_LDO_LT = RTL.new (HppaRTL.COMCLR_LDO_LT {r1=TMP5, r2=TMP7, t1=TMP8, i=TMP0, b=TMP2, t2=TMP9})
         val COMCLR_LDO_LE = RTL.new (HppaRTL.COMCLR_LDO_LE {r1=TMP5, r2=TMP7, t1=TMP8, i=TMP0, b=TMP2, t2=TMP9})
         val COMCLR_LDO_LTU = RTL.new (HppaRTL.COMCLR_LDO_LTU {r1=TMP5, r2=TMP7, t1=TMP8, i=TMP0, b=TMP2, t2=TMP9})
         val COMCLR_LDO_LEU = RTL.new (HppaRTL.COMCLR_LDO_LEU {r1=TMP5, r2=TMP7, t1=TMP8, i=TMP0, b=TMP2, t2=TMP9})
         val COMCLR_LDO_NE = RTL.new (HppaRTL.COMCLR_LDO_NE {r1=TMP5, r2=TMP7, t1=TMP8, i=TMP0, b=TMP2, t2=TMP9})
         val COMCLR_LDO_GE = RTL.new (HppaRTL.COMCLR_LDO_GE {r1=TMP5, r2=TMP7, t1=TMP8, i=TMP0, b=TMP2, t2=TMP9})
         val COMCLR_LDO_GT = RTL.new (HppaRTL.COMCLR_LDO_GT {r1=TMP5, r2=TMP7, t1=TMP8, i=TMP0, b=TMP2, t2=TMP9})
         val COMCLR_LDO_GTU = RTL.new (HppaRTL.COMCLR_LDO_GTU {r1=TMP5, r2=TMP7, t1=TMP8, i=TMP0, b=TMP2, t2=TMP9})
         val COMCLR_LDO_GEU = RTL.new (HppaRTL.COMCLR_LDO_GEU {r1=TMP5, r2=TMP7, t1=TMP8, i=TMP0, b=TMP2, t2=TMP9})
         val COMCLR_LDO2_EQ = RTL.new (HppaRTL.COMCLR_LDO2_EQ {r1=TMP5, r2=TMP7, t1=TMP0, i=TMP0, b=TMP2})
         val COMCLR_LDO2_LT = RTL.new (HppaRTL.COMCLR_LDO2_LT {r1=TMP5, r2=TMP7, t1=TMP0, i=TMP0, b=TMP2})
         val COMCLR_LDO2_LE = RTL.new (HppaRTL.COMCLR_LDO2_LE {r1=TMP5, r2=TMP7, t1=TMP0, i=TMP0, b=TMP2})
         val COMCLR_LDO2_LTU = RTL.new (HppaRTL.COMCLR_LDO2_LTU {r1=TMP5, r2=TMP7, t1=TMP0, i=TMP0, b=TMP2})
         val COMCLR_LDO2_LEU = RTL.new (HppaRTL.COMCLR_LDO2_LEU {r1=TMP5, r2=TMP7, t1=TMP0, i=TMP0, b=TMP2})
         val COMCLR_LDO2_NE = RTL.new (HppaRTL.COMCLR_LDO2_NE {r1=TMP5, r2=TMP7, t1=TMP0, i=TMP0, b=TMP2})
         val COMCLR_LDO2_GE = RTL.new (HppaRTL.COMCLR_LDO2_GE {r1=TMP5, r2=TMP7, t1=TMP0, i=TMP0, b=TMP2})
         val COMCLR_LDO2_GT = RTL.new (HppaRTL.COMCLR_LDO2_GT {r1=TMP5, r2=TMP7, t1=TMP0, i=TMP0, b=TMP2})
         val COMCLR_LDO2_GTU = RTL.new (HppaRTL.COMCLR_LDO2_GTU {r1=TMP5, r2=TMP7, t1=TMP0, i=TMP0, b=TMP2})
         val COMCLR_LDO2_GEU = RTL.new (HppaRTL.COMCLR_LDO2_GEU {r1=TMP5, r2=TMP7, t1=TMP0, i=TMP0, b=TMP2})
         val COMCLR_LDO3_EQ = RTL.new (HppaRTL.COMCLR_LDO3_EQ {r1=TMP5, r2=TMP7, t2=TMP8, i=TMP0, b=TMP2})
         val COMCLR_LDO3_LT = RTL.new (HppaRTL.COMCLR_LDO3_LT {r1=TMP5, r2=TMP7, t2=TMP8, i=TMP0, b=TMP2})
         val COMCLR_LDO3_LE = RTL.new (HppaRTL.COMCLR_LDO3_LE {r1=TMP5, r2=TMP7, t2=TMP8, i=TMP0, b=TMP2})
         val COMCLR_LDO3_LTU = RTL.new (HppaRTL.COMCLR_LDO3_LTU {r1=TMP5, r2=TMP7, t2=TMP8, i=TMP0, b=TMP2})
         val COMCLR_LDO3_LEU = RTL.new (HppaRTL.COMCLR_LDO3_LEU {r1=TMP5, r2=TMP7, t2=TMP8, i=TMP0, b=TMP2})
         val COMCLR_LDO3_NE = RTL.new (HppaRTL.COMCLR_LDO3_NE {r1=TMP5, r2=TMP7, t2=TMP8, i=TMP0, b=TMP2})
         val COMCLR_LDO3_GE = RTL.new (HppaRTL.COMCLR_LDO3_GE {r1=TMP5, r2=TMP7, t2=TMP8, i=TMP0, b=TMP2})
         val COMCLR_LDO3_GT = RTL.new (HppaRTL.COMCLR_LDO3_GT {r1=TMP5, r2=TMP7, t2=TMP8, i=TMP0, b=TMP2})
         val COMCLR_LDO3_GTU = RTL.new (HppaRTL.COMCLR_LDO3_GTU {r1=TMP5, r2=TMP7, t2=TMP8, i=TMP0, b=TMP2})
         val COMCLR_LDO3_GEU = RTL.new (HppaRTL.COMCLR_LDO3_GEU {r1=TMP5, r2=TMP7, t2=TMP8, i=TMP0, b=TMP2})
         val COMICLR_LDO_EQ = RTL.new (HppaRTL.COMICLR_LDO_EQ {i1=TMP0, r2=TMP7, t1=TMP8, i2=TMP2, b=TMP5, t2=TMP9})
         val COMICLR_LDO_LT = RTL.new (HppaRTL.COMICLR_LDO_LT {i1=TMP0, r2=TMP7, t1=TMP8, i2=TMP2, b=TMP5, t2=TMP9})
         val COMICLR_LDO_LE = RTL.new (HppaRTL.COMICLR_LDO_LE {i1=TMP0, r2=TMP7, t1=TMP8, i2=TMP2, b=TMP5, t2=TMP9})
         val COMICLR_LDO_LTU = RTL.new (HppaRTL.COMICLR_LDO_LTU {i1=TMP0, r2=TMP7, t1=TMP8, i2=TMP2, b=TMP5, t2=TMP9})
         val COMICLR_LDO_LEU = RTL.new (HppaRTL.COMICLR_LDO_LEU {i1=TMP0, r2=TMP7, t1=TMP8, i2=TMP2, b=TMP5, t2=TMP9})
         val COMICLR_LDO_NE = RTL.new (HppaRTL.COMICLR_LDO_NE {i1=TMP0, r2=TMP7, t1=TMP8, i2=TMP2, b=TMP5, t2=TMP9})
         val COMICLR_LDO_GE = RTL.new (HppaRTL.COMICLR_LDO_GE {i1=TMP0, r2=TMP7, t1=TMP8, i2=TMP2, b=TMP5, t2=TMP9})
         val COMICLR_LDO_GT = RTL.new (HppaRTL.COMICLR_LDO_GT {i1=TMP0, r2=TMP7, t1=TMP8, i2=TMP2, b=TMP5, t2=TMP9})
         val COMICLR_LDO_GTU = RTL.new (HppaRTL.COMICLR_LDO_GTU {i1=TMP0, r2=TMP7, t1=TMP8, i2=TMP2, b=TMP5, t2=TMP9})
         val COMICLR_LDO_GEU = RTL.new (HppaRTL.COMICLR_LDO_GEU {i1=TMP0, r2=TMP7, t1=TMP8, i2=TMP2, b=TMP5, t2=TMP9})
         val COMICLR_LDO2_EQ = RTL.new (HppaRTL.COMICLR_LDO2_EQ {i1=TMP0, r2=TMP7, t1=TMP0, i2=TMP2, b=TMP5})
         val COMICLR_LDO2_LT = RTL.new (HppaRTL.COMICLR_LDO2_LT {i1=TMP0, r2=TMP7, t1=TMP0, i2=TMP2, b=TMP5})
         val COMICLR_LDO2_LE = RTL.new (HppaRTL.COMICLR_LDO2_LE {i1=TMP0, r2=TMP7, t1=TMP0, i2=TMP2, b=TMP5})
         val COMICLR_LDO2_LTU = RTL.new (HppaRTL.COMICLR_LDO2_LTU {i1=TMP0, r2=TMP7, t1=TMP0, i2=TMP2, b=TMP5})
         val COMICLR_LDO2_LEU = RTL.new (HppaRTL.COMICLR_LDO2_LEU {i1=TMP0, r2=TMP7, t1=TMP0, i2=TMP2, b=TMP5})
         val COMICLR_LDO2_NE = RTL.new (HppaRTL.COMICLR_LDO2_NE {i1=TMP0, r2=TMP7, t1=TMP0, i2=TMP2, b=TMP5})
         val COMICLR_LDO2_GE = RTL.new (HppaRTL.COMICLR_LDO2_GE {i1=TMP0, r2=TMP7, t1=TMP0, i2=TMP2, b=TMP5})
         val COMICLR_LDO2_GT = RTL.new (HppaRTL.COMICLR_LDO2_GT {i1=TMP0, r2=TMP7, t1=TMP0, i2=TMP2, b=TMP5})
         val COMICLR_LDO2_GTU = RTL.new (HppaRTL.COMICLR_LDO2_GTU {i1=TMP0, r2=TMP7, t1=TMP0, i2=TMP2, b=TMP5})
         val COMICLR_LDO2_GEU = RTL.new (HppaRTL.COMICLR_LDO2_GEU {i1=TMP0, r2=TMP7, t1=TMP0, i2=TMP2, b=TMP5})
         val COMICLR_LDO3_EQ = RTL.new (HppaRTL.COMICLR_LDO3_EQ {i1=TMP0, r2=TMP7, t2=TMP8, i2=TMP2, b=TMP5})
         val COMICLR_LDO3_LT = RTL.new (HppaRTL.COMICLR_LDO3_LT {i1=TMP0, r2=TMP7, t2=TMP8, i2=TMP2, b=TMP5})
         val COMICLR_LDO3_LE = RTL.new (HppaRTL.COMICLR_LDO3_LE {i1=TMP0, r2=TMP7, t2=TMP8, i2=TMP2, b=TMP5})
         val COMICLR_LDO3_LTU = RTL.new (HppaRTL.COMICLR_LDO3_LTU {i1=TMP0, r2=TMP7, t2=TMP8, i2=TMP2, b=TMP5})
         val COMICLR_LDO3_LEU = RTL.new (HppaRTL.COMICLR_LDO3_LEU {i1=TMP0, r2=TMP7, t2=TMP8, i2=TMP2, b=TMP5})
         val COMICLR_LDO3_NE = RTL.new (HppaRTL.COMICLR_LDO3_NE {i1=TMP0, r2=TMP7, t2=TMP8, i2=TMP2, b=TMP5})
         val COMICLR_LDO3_GE = RTL.new (HppaRTL.COMICLR_LDO3_GE {i1=TMP0, r2=TMP7, t2=TMP8, i2=TMP2, b=TMP5})
         val COMICLR_LDO3_GT = RTL.new (HppaRTL.COMICLR_LDO3_GT {i1=TMP0, r2=TMP7, t2=TMP8, i2=TMP2, b=TMP5})
         val COMICLR_LDO3_GTU = RTL.new (HppaRTL.COMICLR_LDO3_GTU {i1=TMP0, r2=TMP7, t2=TMP8, i2=TMP2, b=TMP5})
         val COMICLR_LDO3_GEU = RTL.new (HppaRTL.COMICLR_LDO3_GEU {i1=TMP0, r2=TMP7, t2=TMP8, i2=TMP2, b=TMP5})
         val COMBT_EQ = RTL.new (HppaRTL.COMBT_EQ {r1=TMP0, r2=TMP2, t=TMP6})
         val COMBT_LT = RTL.new (HppaRTL.COMBT_LT {r1=TMP0, r2=TMP2, t=TMP6})
         val COMBT_LE = RTL.new (HppaRTL.COMBT_LE {r1=TMP0, r2=TMP2, t=TMP6})
         val COMBT_LTU = RTL.new (HppaRTL.COMBT_LTU {r1=TMP0, r2=TMP2, t=TMP6})
         val COMBT_LEU = RTL.new (HppaRTL.COMBT_LEU {r1=TMP0, r2=TMP2, t=TMP6})
         val COMBT_NE = RTL.new (HppaRTL.COMBT_NE {r1=TMP0, r2=TMP2, t=TMP6})
         val COMBT_GE = RTL.new (HppaRTL.COMBT_GE {r1=TMP0, r2=TMP2, t=TMP6})
         val COMBT_GT = RTL.new (HppaRTL.COMBT_GT {r1=TMP0, r2=TMP2, t=TMP6})
         val COMBT_GTU = RTL.new (HppaRTL.COMBT_GTU {r1=TMP0, r2=TMP2, t=TMP6})
         val COMBT_GEU = RTL.new (HppaRTL.COMBT_GEU {r1=TMP0, r2=TMP2, t=TMP6})
         val COMBF_EQ = RTL.new (HppaRTL.COMBF_EQ {r1=TMP0, r2=TMP2, t=TMP6})
         val COMBF_LT = RTL.new (HppaRTL.COMBF_LT {r1=TMP0, r2=TMP2, t=TMP6})
         val COMBF_LE = RTL.new (HppaRTL.COMBF_LE {r1=TMP0, r2=TMP2, t=TMP6})
         val COMBF_LTU = RTL.new (HppaRTL.COMBF_LTU {r1=TMP0, r2=TMP2, t=TMP6})
         val COMBF_LEU = RTL.new (HppaRTL.COMBF_LEU {r1=TMP0, r2=TMP2, t=TMP6})
         val COMBF_NE = RTL.new (HppaRTL.COMBF_NE {r1=TMP0, r2=TMP2, t=TMP6})
         val COMBF_GE = RTL.new (HppaRTL.COMBF_GE {r1=TMP0, r2=TMP2, t=TMP6})
         val COMBF_GT = RTL.new (HppaRTL.COMBF_GT {r1=TMP0, r2=TMP2, t=TMP6})
         val COMBF_GTU = RTL.new (HppaRTL.COMBF_GTU {r1=TMP0, r2=TMP2, t=TMP6})
         val COMBF_GEU = RTL.new (HppaRTL.COMBF_GEU {r1=TMP0, r2=TMP2, t=TMP6})
         val COMIBT_EQ = RTL.new (HppaRTL.COMIBT_EQ {i=TMP0, r2=TMP2, t=TMP6})
         val COMIBT_LT = RTL.new (HppaRTL.COMIBT_LT {i=TMP0, r2=TMP2, t=TMP6})
         val COMIBT_LE = RTL.new (HppaRTL.COMIBT_LE {i=TMP0, r2=TMP2, t=TMP6})
         val COMIBT_LTU = RTL.new (HppaRTL.COMIBT_LTU {i=TMP0, r2=TMP2, t=TMP6})
         val COMIBT_LEU = RTL.new (HppaRTL.COMIBT_LEU {i=TMP0, r2=TMP2, t=TMP6})
         val COMIBT_NE = RTL.new (HppaRTL.COMIBT_NE {i=TMP0, r2=TMP2, t=TMP6})
         val COMIBT_GE = RTL.new (HppaRTL.COMIBT_GE {i=TMP0, r2=TMP2, t=TMP6})
         val COMIBT_GT = RTL.new (HppaRTL.COMIBT_GT {i=TMP0, r2=TMP2, t=TMP6})
         val COMIBT_GTU = RTL.new (HppaRTL.COMIBT_GTU {i=TMP0, r2=TMP2, t=TMP6})
         val COMIBT_GEU = RTL.new (HppaRTL.COMIBT_GEU {i=TMP0, r2=TMP2, t=TMP6})
         val COMIBF_EQ = RTL.new (HppaRTL.COMIBF_EQ {i=TMP0, r2=TMP2, t=TMP6})
         val COMIBF_LT = RTL.new (HppaRTL.COMIBF_LT {i=TMP0, r2=TMP2, t=TMP6})
         val COMIBF_LE = RTL.new (HppaRTL.COMIBF_LE {i=TMP0, r2=TMP2, t=TMP6})
         val COMIBF_LTU = RTL.new (HppaRTL.COMIBF_LTU {i=TMP0, r2=TMP2, t=TMP6})
         val COMIBF_LEU = RTL.new (HppaRTL.COMIBF_LEU {i=TMP0, r2=TMP2, t=TMP6})
         val COMIBF_NE = RTL.new (HppaRTL.COMIBF_NE {i=TMP0, r2=TMP2, t=TMP6})
         val COMIBF_GE = RTL.new (HppaRTL.COMIBF_GE {i=TMP0, r2=TMP2, t=TMP6})
         val COMIBF_GT = RTL.new (HppaRTL.COMIBF_GT {i=TMP0, r2=TMP2, t=TMP6})
         val COMIBF_GTU = RTL.new (HppaRTL.COMIBF_GTU {i=TMP0, r2=TMP2, t=TMP6})
         val COMIBF_GEU = RTL.new (HppaRTL.COMIBF_GEU {i=TMP0, r2=TMP2, t=TMP6})
         val B = RTL.new (HppaRTL.B {lab=TMP6})
         val BV = RTL.new (HppaRTL.BV {x=TMP2, b=TMP0})
         val BB_BSET = RTL.new (HppaRTL.BB_BSET {p=TMP0, r=TMP2, t=TMP6})
         val BB_BCLR = RTL.new (HppaRTL.BB_BCLR {p=TMP0, r=TMP2, t=TMP6})
         val BLE = RTL.new (HppaRTL.BLE {d=TMP0, b=TMP2, defs=TMP10, uses=TMP3, mem=TMP11})
         val FLDDS = RTL.new (HppaRTL.FLDDS {b=TMP2, d=TMP0, t=TMP1, mem=TMP3})
         val FLDWS = RTL.new (HppaRTL.FLDWS {b=TMP2, d=TMP0, t=TMP1, mem=TMP3})
         val FLDDX = RTL.new (HppaRTL.FLDDX {b=TMP0, x=TMP2, t=TMP1, mem=TMP3})
         val FLDDX_S = RTL.new (HppaRTL.FLDDX_S {b=TMP0, x=TMP2, t=TMP1, mem=TMP3})
         val FLDDX_M = RTL.new (HppaRTL.FLDDX_M {b=TMP4, x=TMP2, t=TMP12, mem=TMP3})
         val FLDDX_SM = RTL.new (HppaRTL.FLDDX_SM {b=TMP4, x=TMP2, t=TMP12, mem=TMP3})
         val FLDWX = RTL.new (HppaRTL.FLDWX {b=TMP0, x=TMP2, t=TMP1, mem=TMP3})
         val FLDWX_S = RTL.new (HppaRTL.FLDWX_S {b=TMP0, x=TMP2, t=TMP1, mem=TMP3})
         val FLDWX_M = RTL.new (HppaRTL.FLDWX_M {b=TMP4, x=TMP2, t=TMP12, mem=TMP3})
         val FLDWX_SM = RTL.new (HppaRTL.FLDWX_SM {b=TMP4, x=TMP2, t=TMP12, mem=TMP3})
         val FSTDS = RTL.new (HppaRTL.FSTDS {b=TMP2, d=TMP0, r=TMP13, mem=TMP6})
         val FSTWS = RTL.new (HppaRTL.FSTWS {b=TMP2, d=TMP0, r=TMP13, mem=TMP6})
         val FSTDX = RTL.new (HppaRTL.FSTDX {b=TMP0, x=TMP5, r=TMP12, mem=TMP6})
         val FSTDX_S = RTL.new (HppaRTL.FSTDX_S {b=TMP0, x=TMP5, r=TMP12, mem=TMP6})
         val FSTDX_M = RTL.new (HppaRTL.FSTDX_M {b=TMP4, x=TMP5, r=TMP12, mem=TMP10})
         val FSTDX_SM = RTL.new (HppaRTL.FSTDX_SM {b=TMP4, x=TMP5, r=TMP12, mem=TMP10})
         val FSTWX = RTL.new (HppaRTL.FSTWX {b=TMP0, x=TMP5, r=TMP12, mem=TMP6})
         val FSTWX_S = RTL.new (HppaRTL.FSTWX_S {b=TMP0, x=TMP5, r=TMP12, mem=TMP6})
         val FSTWX_M = RTL.new (HppaRTL.FSTWX_M {b=TMP4, x=TMP5, r=TMP12, mem=TMP10})
         val FSTWX_SM = RTL.new (HppaRTL.FSTWX_SM {b=TMP4, x=TMP5, r=TMP12, mem=TMP10})
         val FADD_S = RTL.new (HppaRTL.FADD_S {r1=TMP1, r2=TMP12, t=TMP1})
         val FADD_D = RTL.new (HppaRTL.FADD_D {r1=TMP1, r2=TMP12, t=TMP1})
         val FADD_Q = RTL.new (HppaRTL.FADD_Q {r1=TMP1, r2=TMP12, t=TMP1})
         val FSUB_S = RTL.new (HppaRTL.FSUB_S {r1=TMP1, r2=TMP12, t=TMP1})
         val FSUB_D = RTL.new (HppaRTL.FSUB_D {r1=TMP1, r2=TMP12, t=TMP1})
         val FSUB_Q = RTL.new (HppaRTL.FSUB_Q {r1=TMP1, r2=TMP12, t=TMP1})
         val FMPY_S = RTL.new (HppaRTL.FMPY_S {r1=TMP1, r2=TMP12, t=TMP1})
         val FMPY_D = RTL.new (HppaRTL.FMPY_D {r1=TMP1, r2=TMP12, t=TMP1})
         val FMPY_Q = RTL.new (HppaRTL.FMPY_Q {r1=TMP1, r2=TMP12, t=TMP1})
         val FDIV_S = RTL.new (HppaRTL.FDIV_S {r1=TMP1, r2=TMP12, t=TMP1})
         val FDIV_D = RTL.new (HppaRTL.FDIV_D {r1=TMP1, r2=TMP12, t=TMP1})
         val FDIV_Q = RTL.new (HppaRTL.FDIV_Q {r1=TMP1, r2=TMP12, t=TMP1})
         val XMPYU = RTL.new (HppaRTL.XMPYU {r1=TMP1, r2=TMP12, t=TMP1})
         val FCPY_S = RTL.new (HppaRTL.FCPY_S {f=TMP1, t=TMP1})
         val FCPY_D = RTL.new (HppaRTL.FCPY_D {f=TMP1, t=TMP1})
         val FCPY_Q = RTL.new (HppaRTL.FCPY_Q {f=TMP1, t=TMP1})
         val FABS_S = RTL.new (HppaRTL.FABS_S {f=TMP1, t=TMP1})
         val FABS_D = RTL.new (HppaRTL.FABS_D {f=TMP1, t=TMP1})
         val FABS_Q = RTL.new (HppaRTL.FABS_Q {f=TMP1, t=TMP1})
         val FSQRT_S = RTL.new (HppaRTL.FSQRT_S {f=TMP1, t=TMP1})
         val FSQRT_D = RTL.new (HppaRTL.FSQRT_D {f=TMP1, t=TMP1})
         val FSQRT_Q = RTL.new (HppaRTL.FSQRT_Q {f=TMP1, t=TMP1})
         val FRND_S = RTL.new (HppaRTL.FRND_S {f=TMP1, t=TMP1})
         val FRND_D = RTL.new (HppaRTL.FRND_D {f=TMP1, t=TMP1})
         val FRND_Q = RTL.new (HppaRTL.FRND_Q {f=TMP1, t=TMP1})
         val FCNVFF_SD = RTL.new (HppaRTL.FCNVFF_SD {f=TMP1, t=TMP1})
         val FCNVFF_SQ = RTL.new (HppaRTL.FCNVFF_SQ {f=TMP1, t=TMP1})
         val FCNVFF_DS = RTL.new (HppaRTL.FCNVFF_DS {f=TMP1, t=TMP1})
         val FCNVFF_DQ = RTL.new (HppaRTL.FCNVFF_DQ {f=TMP1, t=TMP1})
         val FCNVFF_QS = RTL.new (HppaRTL.FCNVFF_QS {f=TMP1, t=TMP1})
         val FCNVFF_QD = RTL.new (HppaRTL.FCNVFF_QD {f=TMP1, t=TMP1})
         val FCNVXF_S = RTL.new (HppaRTL.FCNVXF_S {f=TMP1, t=TMP1})
         val FCNVXF_D = RTL.new (HppaRTL.FCNVXF_D {f=TMP1, t=TMP1})
         val FCNVXF_Q = RTL.new (HppaRTL.FCNVXF_Q {f=TMP1, t=TMP1})
         val FCNVFX_S = RTL.new (HppaRTL.FCNVFX_S {f=TMP1, t=TMP1})
         val FCNVFX_D = RTL.new (HppaRTL.FCNVFX_D {f=TMP1, t=TMP1})
         val FCNVFX_Q = RTL.new (HppaRTL.FCNVFX_Q {f=TMP1, t=TMP1})
         val FCNVFXT_S = RTL.new (HppaRTL.FCNVFXT_S {f=TMP1, t=TMP1})
         val FCNVFXT_D = RTL.new (HppaRTL.FCNVFXT_D {f=TMP1, t=TMP1})
         val FCNVFXT_Q = RTL.new (HppaRTL.FCNVFXT_Q {f=TMP1, t=TMP1})
         val FBRANCH__63 = RTL.new (HppaRTL.FBRANCH__63 {f1=TMP1, f2=TMP12, t=TMP6})
         val FBRANCH__33_60_61_62 = RTL.new (HppaRTL.FBRANCH__33_60_61_62 {f1=TMP1, f2=TMP12, t=TMP6})
         val FBRANCH__61_61 = RTL.new (HppaRTL.FBRANCH__61_61 {f1=TMP1, f2=TMP12, t=TMP6})
         val FBRANCH__63_61 = RTL.new (HppaRTL.FBRANCH__63_61 {f1=TMP1, f2=TMP12, t=TMP6})
         val FBRANCH__33_60_62 = RTL.new (HppaRTL.FBRANCH__33_60_62 {f1=TMP1, f2=TMP12, t=TMP6})
         val FBRANCH__33_63_62_61 = RTL.new (HppaRTL.FBRANCH__33_63_62_61 {f1=TMP1, f2=TMP12, t=TMP6})
         val FBRANCH__60 = RTL.new (HppaRTL.FBRANCH__60 {f1=TMP1, f2=TMP12, t=TMP6})
         val FBRANCH__63_60 = RTL.new (HppaRTL.FBRANCH__63_60 {f1=TMP1, f2=TMP12, t=TMP6})
         val FBRANCH__33_62_61 = RTL.new (HppaRTL.FBRANCH__33_62_61 {f1=TMP1, f2=TMP12, t=TMP6})
         val FBRANCH__33_63_62 = RTL.new (HppaRTL.FBRANCH__33_63_62 {f1=TMP1, f2=TMP12, t=TMP6})
         val FBRANCH__60_61 = RTL.new (HppaRTL.FBRANCH__60_61 {f1=TMP1, f2=TMP12, t=TMP6})
         val FBRANCH__63_60_61 = RTL.new (HppaRTL.FBRANCH__63_60_61 {f1=TMP1, f2=TMP12, t=TMP6})
         val FBRANCH__33_62 = RTL.new (HppaRTL.FBRANCH__33_62 {f1=TMP1, f2=TMP12, t=TMP6})
         val FBRANCH__33_63_60_61 = RTL.new (HppaRTL.FBRANCH__33_63_60_61 {f1=TMP1, f2=TMP12, t=TMP6})
         val FBRANCH__62 = RTL.new (HppaRTL.FBRANCH__62 {f1=TMP1, f2=TMP12, t=TMP6})
         val FBRANCH__63_62 = RTL.new (HppaRTL.FBRANCH__63_62 {f1=TMP1, f2=TMP12, t=TMP6})
         val FBRANCH__33_60_61 = RTL.new (HppaRTL.FBRANCH__33_60_61 {f1=TMP1, f2=TMP12, t=TMP6})
         val FBRANCH__33_63_60 = RTL.new (HppaRTL.FBRANCH__33_63_60 {f1=TMP1, f2=TMP12, t=TMP6})
         val FBRANCH__62_61 = RTL.new (HppaRTL.FBRANCH__62_61 {f1=TMP1, f2=TMP12, t=TMP6})
         val FBRANCH__63_62_61 = RTL.new (HppaRTL.FBRANCH__63_62_61 {f1=TMP1, f2=TMP12, t=TMP6})
         val FBRANCH__33_60 = RTL.new (HppaRTL.FBRANCH__33_60 {f1=TMP1, f2=TMP12, t=TMP6})
         val FBRANCH__33_63_61 = RTL.new (HppaRTL.FBRANCH__33_63_61 {f1=TMP1, f2=TMP12, t=TMP6})
         val FBRANCH__60_62 = RTL.new (HppaRTL.FBRANCH__60_62 {f1=TMP1, f2=TMP12, t=TMP6})
         val FBRANCH__33_61 = RTL.new (HppaRTL.FBRANCH__33_61 {f1=TMP1, f2=TMP12, t=TMP6})
         val FBRANCH__33_63 = RTL.new (HppaRTL.FBRANCH__33_63 {f1=TMP1, f2=TMP12, t=TMP6})
         val FBRANCH__60_61_62 = RTL.new (HppaRTL.FBRANCH__60_61_62 {f1=TMP1, f2=TMP12, t=TMP6})
         val FBRANCH__63_60_62 = RTL.new (HppaRTL.FBRANCH__63_60_62 {f1=TMP1, f2=TMP12, t=TMP6})
      end
   end

   fun rtl instr = let
          fun undefined () = bug ("rtl", instr)
          fun query (I.LOADI{li, r, i, t, mem}) = 
              (
               case li of
               I.LDW => Arch.LDW
             | I.LDH => Arch.LDH
             | I.LDB => Arch.LDB
              )
            | query (I.LOAD{l, r1, r2, t, mem}) = 
              (
               case l of
               I.LDWX => Arch.LDWX
             | I.LDWX_S => Arch.LDWX_S
             | I.LDWX_M => Arch.LDWX_M
             | I.LDWX_SM => Arch.LDWX_SM
             | I.LDHX => Arch.LDHX
             | I.LDHX_S => Arch.LDHX_S
             | I.LDHX_M => Arch.LDHX_M
             | I.LDHX_SM => Arch.LDHX_SM
             | I.LDBX => Arch.LDBX
             | I.LDBX_M => Arch.LDBX_M
              )
            | query (I.STORE{st, b, d, r, mem}) = 
              (
               case st of
               I.STW => Arch.STW
             | I.STH => Arch.STH
             | I.STB => Arch.STB
              )
            | query (I.ARITH{a, r1, r2, t}) = 
              (
               case a of
               I.ADD => Arch.ADD
             | I.ADDL => Arch.ADDL
             | I.ADDO => Arch.ADDO
             | I.SH1ADD => Arch.SH1ADD
             | I.SH1ADDL => Arch.SH1ADDL
             | I.SH1ADDO => Arch.SH1ADDO
             | I.SH2ADD => Arch.SH2ADD
             | I.SH2ADDL => Arch.SH2ADDL
             | I.SH2ADDO => Arch.SH2ADDO
             | I.SH3ADD => Arch.SH3ADD
             | I.SH3ADDL => Arch.SH3ADDL
             | I.SH3ADDO => Arch.SH3ADDO
             | I.SUB => Arch.SUB
             | I.SUBO => Arch.SUBO
             | I.OR => Arch.OR
             | I.XOR => Arch.XOR
             | I.AND => Arch.AND
             | I.ANDCM => Arch.ANDCM
              )
            | query (I.ARITHI{ai, i, r, t}) = 
              (
               case ai of
               I.ADDI => Arch.ADDI
             | I.ADDIO => Arch.ADDIO
             | I.ADDIL => Arch.ADDIL
             | I.SUBI => Arch.SUBI
             | I.SUBIO => Arch.SUBIO
              )
            | query (I.COMCLR_LDO{cc, r1, r2, t1, i, b, t2}) = (if (t1 = t2)
                 then 
                 (
                  case cc of
                  I.EQ => Arch.COMCLR_LDO2_EQ
                | I.LT => Arch.COMCLR_LDO2_LT
                | I.LE => Arch.COMCLR_LDO2_LE
                | I.LTU => Arch.COMCLR_LDO2_LTU
                | I.LEU => Arch.COMCLR_LDO2_LEU
                | I.NE => Arch.COMCLR_LDO2_NE
                | I.GE => Arch.COMCLR_LDO2_GE
                | I.GT => Arch.COMCLR_LDO2_GT
                | I.GTU => Arch.COMCLR_LDO2_GTU
                | I.GEU => Arch.COMCLR_LDO2_GEU
                 )
                 else (if (t1 = 0)
                    then 
                    (
                     case cc of
                     I.EQ => Arch.COMCLR_LDO3_EQ
                   | I.LT => Arch.COMCLR_LDO3_LT
                   | I.LE => Arch.COMCLR_LDO3_LE
                   | I.LTU => Arch.COMCLR_LDO3_LTU
                   | I.LEU => Arch.COMCLR_LDO3_LEU
                   | I.NE => Arch.COMCLR_LDO3_NE
                   | I.GE => Arch.COMCLR_LDO3_GE
                   | I.GT => Arch.COMCLR_LDO3_GT
                   | I.GTU => Arch.COMCLR_LDO3_GTU
                   | I.GEU => Arch.COMCLR_LDO3_GEU
                    )
                    else 
                    (
                     case cc of
                     I.EQ => Arch.COMCLR_LDO_EQ
                   | I.LT => Arch.COMCLR_LDO_LT
                   | I.LE => Arch.COMCLR_LDO_LE
                   | I.LTU => Arch.COMCLR_LDO_LTU
                   | I.LEU => Arch.COMCLR_LDO_LEU
                   | I.NE => Arch.COMCLR_LDO_NE
                   | I.GE => Arch.COMCLR_LDO_GE
                   | I.GT => Arch.COMCLR_LDO_GT
                   | I.GTU => Arch.COMCLR_LDO_GTU
                   | I.GEU => Arch.COMCLR_LDO_GEU
                    )))
            | query (I.COMICLR_LDO{cc, i1, r2, t1, i2, b, t2}) = (if (t1 = t2)
                 then 
                 (
                  case cc of
                  I.EQ => Arch.COMICLR_LDO2_EQ
                | I.LT => Arch.COMICLR_LDO2_LT
                | I.LE => Arch.COMICLR_LDO2_LE
                | I.LTU => Arch.COMICLR_LDO2_LTU
                | I.LEU => Arch.COMICLR_LDO2_LEU
                | I.NE => Arch.COMICLR_LDO2_NE
                | I.GE => Arch.COMICLR_LDO2_GE
                | I.GT => Arch.COMICLR_LDO2_GT
                | I.GTU => Arch.COMICLR_LDO2_GTU
                | I.GEU => Arch.COMICLR_LDO2_GEU
                 )
                 else (if (t1 = 0)
                    then 
                    (
                     case cc of
                     I.EQ => Arch.COMICLR_LDO3_EQ
                   | I.LT => Arch.COMICLR_LDO3_LT
                   | I.LE => Arch.COMICLR_LDO3_LE
                   | I.LTU => Arch.COMICLR_LDO3_LTU
                   | I.LEU => Arch.COMICLR_LDO3_LEU
                   | I.NE => Arch.COMICLR_LDO3_NE
                   | I.GE => Arch.COMICLR_LDO3_GE
                   | I.GT => Arch.COMICLR_LDO3_GT
                   | I.GTU => Arch.COMICLR_LDO3_GTU
                   | I.GEU => Arch.COMICLR_LDO3_GEU
                    )
                    else 
                    (
                     case cc of
                     I.EQ => Arch.COMICLR_LDO_EQ
                   | I.LT => Arch.COMICLR_LDO_LT
                   | I.LE => Arch.COMICLR_LDO_LE
                   | I.LTU => Arch.COMICLR_LDO_LTU
                   | I.LEU => Arch.COMICLR_LDO_LEU
                   | I.NE => Arch.COMICLR_LDO_NE
                   | I.GE => Arch.COMICLR_LDO_GE
                   | I.GT => Arch.COMICLR_LDO_GT
                   | I.GTU => Arch.COMICLR_LDO_GTU
                   | I.GEU => Arch.COMICLR_LDO_GEU
                    )))
            | query (I.SHIFTV{sv, r, len, t}) = 
              (
               case sv of
               I.VEXTRU => Arch.VEXTRU
             | I.VEXTRS => Arch.VEXTRS
             | I.ZVDEP => Arch.ZVDEP
              )
            | query (I.SHIFT{s, r, p, len, t}) = 
              (
               case s of
               I.EXTRU => Arch.EXTRU
             | I.EXTRS => Arch.EXTRS
             | I.ZDEP => Arch.ZDEP
              )
            | query (I.BCOND{cmp, bc, r1, r2, n, nop, t, f}) = 
              (
               case (cmp, bc) of
               (I.COMBT, I.EQ) => Arch.COMBT_EQ
             | (I.COMBF, I.EQ) => Arch.COMBF_EQ
             | (I.COMBT, I.LT) => Arch.COMBT_LT
             | (I.COMBF, I.LT) => Arch.COMBF_LT
             | (I.COMBT, I.LE) => Arch.COMBT_LE
             | (I.COMBF, I.LE) => Arch.COMBF_LE
             | (I.COMBT, I.LTU) => Arch.COMBT_LTU
             | (I.COMBF, I.LTU) => Arch.COMBF_LTU
             | (I.COMBT, I.LEU) => Arch.COMBT_LEU
             | (I.COMBF, I.LEU) => Arch.COMBF_LEU
             | (I.COMBT, I.NE) => Arch.COMBT_NE
             | (I.COMBF, I.NE) => Arch.COMBF_NE
             | (I.COMBT, I.GE) => Arch.COMBT_GE
             | (I.COMBF, I.GE) => Arch.COMBF_GE
             | (I.COMBT, I.GT) => Arch.COMBT_GT
             | (I.COMBF, I.GT) => Arch.COMBF_GT
             | (I.COMBT, I.GTU) => Arch.COMBT_GTU
             | (I.COMBF, I.GTU) => Arch.COMBF_GTU
             | (I.COMBT, I.GEU) => Arch.COMBT_GEU
             | (I.COMBF, I.GEU) => Arch.COMBF_GEU
              )
            | query (I.BCONDI{cmpi, bc, i, r2, n, nop, t, f}) = 
              (
               case (cmpi, bc) of
               (I.COMIBT, I.EQ) => Arch.COMIBT_EQ
             | (I.COMIBF, I.EQ) => Arch.COMIBF_EQ
             | (I.COMIBT, I.LT) => Arch.COMIBT_LT
             | (I.COMIBF, I.LT) => Arch.COMIBF_LT
             | (I.COMIBT, I.LE) => Arch.COMIBT_LE
             | (I.COMIBF, I.LE) => Arch.COMIBF_LE
             | (I.COMIBT, I.LTU) => Arch.COMIBT_LTU
             | (I.COMIBF, I.LTU) => Arch.COMIBF_LTU
             | (I.COMIBT, I.LEU) => Arch.COMIBT_LEU
             | (I.COMIBF, I.LEU) => Arch.COMIBF_LEU
             | (I.COMIBT, I.NE) => Arch.COMIBT_NE
             | (I.COMIBF, I.NE) => Arch.COMIBF_NE
             | (I.COMIBT, I.GE) => Arch.COMIBT_GE
             | (I.COMIBF, I.GE) => Arch.COMIBF_GE
             | (I.COMIBT, I.GT) => Arch.COMIBT_GT
             | (I.COMIBF, I.GT) => Arch.COMIBF_GT
             | (I.COMIBT, I.GTU) => Arch.COMIBT_GTU
             | (I.COMIBF, I.GTU) => Arch.COMIBF_GTU
             | (I.COMIBT, I.GEU) => Arch.COMIBT_GEU
             | (I.COMIBF, I.GEU) => Arch.COMIBF_GEU
              )
            | query (I.BB{bc, r, p, n, nop, t, f}) = 
              (
               case bc of
               I.BSET => Arch.BB_BSET
             | I.BCLR => Arch.BB_BCLR
              )
            | query (I.B{lab, n}) = Arch.B
            | query (I.LONGJUMP{lab, n, tmp, tmpLab}) = Arch.B
            | query (I.BV{x, b, labs, n}) = Arch.BV
            | query (I.BLE{d, b, sr, t, defs, uses, mem}) = Arch.BLE
            | query (I.LDIL{i, t}) = Arch.LDIL
            | query (I.LDO{i, b, t}) = (if (b = 0)
                 then Arch.LDO2
                 else Arch.LDO)
            | query (I.MTCTL{r, t}) = Arch.MTCTL
            | query (I.FSTORE{fst, b, d, r, mem}) = 
              (
               case fst of
               I.FSTDS => Arch.FSTDS
             | I.FSTWS => Arch.FSTWS
              )
            | query (I.FSTOREX{fstx, b, x, r, mem}) = 
              (
               case fstx of
               I.FSTDX => Arch.FSTDX
             | I.FSTDX_S => Arch.FSTDX_S
             | I.FSTDX_M => Arch.FSTDX_M
             | I.FSTDX_SM => Arch.FSTDX_SM
             | I.FSTWX => Arch.FSTWX
             | I.FSTWX_S => Arch.FSTWX_S
             | I.FSTWX_M => Arch.FSTWX_M
             | I.FSTWX_SM => Arch.FSTWX_SM
              )
            | query (I.FLOAD{fl, b, d, t, mem}) = 
              (
               case fl of
               I.FLDDS => Arch.FLDDS
             | I.FLDWS => Arch.FLDWS
              )
            | query (I.FLOADX{flx, b, x, t, mem}) = 
              (
               case flx of
               I.FLDDX => Arch.FLDDX
             | I.FLDDX_S => Arch.FLDDX_S
             | I.FLDDX_M => Arch.FLDDX_M
             | I.FLDDX_SM => Arch.FLDDX_SM
             | I.FLDWX => Arch.FLDWX
             | I.FLDWX_S => Arch.FLDWX_S
             | I.FLDWX_M => Arch.FLDWX_M
             | I.FLDWX_SM => Arch.FLDWX_SM
              )
            | query (I.FARITH{fa, r1, r2, t}) = 
              (
               case fa of
               I.FADD_S => Arch.FADD_S
             | I.FADD_D => Arch.FADD_D
             | I.FADD_Q => Arch.FADD_Q
             | I.FSUB_S => Arch.FSUB_S
             | I.FSUB_D => Arch.FSUB_D
             | I.FSUB_Q => Arch.FSUB_Q
             | I.FMPY_S => Arch.FMPY_S
             | I.FMPY_D => Arch.FMPY_D
             | I.FMPY_Q => Arch.FMPY_Q
             | I.FDIV_S => Arch.FDIV_S
             | I.FDIV_D => Arch.FDIV_D
             | I.FDIV_Q => Arch.FDIV_Q
             | I.XMPYU => Arch.XMPYU
              )
            | query (I.FUNARY{fu, f, t}) = 
              (
               case fu of
               I.FCPY_S => Arch.FCPY_S
             | I.FCPY_D => Arch.FCPY_D
             | I.FCPY_Q => Arch.FCPY_Q
             | I.FABS_S => Arch.FABS_S
             | I.FABS_D => Arch.FABS_D
             | I.FABS_Q => Arch.FABS_Q
             | I.FSQRT_S => Arch.FSQRT_S
             | I.FSQRT_D => Arch.FSQRT_D
             | I.FSQRT_Q => Arch.FSQRT_Q
             | I.FRND_S => Arch.FRND_S
             | I.FRND_D => Arch.FRND_D
             | I.FRND_Q => Arch.FRND_Q
              )
            | query (I.FCNV{fcnv, f, t}) = 
              (
               case fcnv of
               I.FCNVFF_SD => Arch.FCNVFF_SD
             | I.FCNVFF_SQ => Arch.FCNVFF_SQ
             | I.FCNVFF_DS => Arch.FCNVFF_DS
             | I.FCNVFF_DQ => Arch.FCNVFF_DQ
             | I.FCNVFF_QS => Arch.FCNVFF_QS
             | I.FCNVFF_QD => Arch.FCNVFF_QD
             | I.FCNVXF_S => Arch.FCNVXF_S
             | I.FCNVXF_D => Arch.FCNVXF_D
             | I.FCNVXF_Q => Arch.FCNVXF_Q
             | I.FCNVFX_S => Arch.FCNVFX_S
             | I.FCNVFX_D => Arch.FCNVFX_D
             | I.FCNVFX_Q => Arch.FCNVFX_Q
             | I.FCNVFXT_S => Arch.FCNVFXT_S
             | I.FCNVFXT_D => Arch.FCNVFXT_D
             | I.FCNVFXT_Q => Arch.FCNVFXT_Q
              )
            | query (I.FBRANCH{cc, fmt, f1, f2, t, f, n, long}) = 
              (
               case cc of
               I.? => Arch.FBRANCH__63
             | I.!<=> => Arch.FBRANCH__33_60_61_62
             | I.== => Arch.FBRANCH__61_61
             | I.?= => Arch.FBRANCH__63_61
             | I.!<> => Arch.FBRANCH__33_60_62
             | I.!?>= => Arch.FBRANCH__33_63_62_61
             | I.< => Arch.FBRANCH__60
             | I.?< => Arch.FBRANCH__63_60
             | I.!>= => Arch.FBRANCH__33_62_61
             | I.!?> => Arch.FBRANCH__33_63_62
             | I.<= => Arch.FBRANCH__60_61
             | I.?<= => Arch.FBRANCH__63_60_61
             | I.!> => Arch.FBRANCH__33_62
             | I.!?<= => Arch.FBRANCH__33_63_60_61
             | I.> => Arch.FBRANCH__62
             | I.?> => Arch.FBRANCH__63_62
             | I.!<= => Arch.FBRANCH__33_60_61
             | I.!?< => Arch.FBRANCH__33_63_60
             | I.>= => Arch.FBRANCH__62_61
             | I.?>= => Arch.FBRANCH__63_62_61
             | I.!< => Arch.FBRANCH__33_60
             | I.!?= => Arch.FBRANCH__33_63_61
             | I.<> => Arch.FBRANCH__60_62
             | I.!= => Arch.FBRANCH__33_61
             | I.!? => Arch.FBRANCH__33_63
             | I.<=> => Arch.FBRANCH__60_61_62
             | (I.False_ | I.False | I.EQT | I.NET | I.True_ | I.True) => undefined ()
              )
            | query (I.NOP) = Arch.NOP
            | query (I.COPY{dst, src, impl, tmp}) = Arch.COPY
            | query (I.FCOPY{dst, src, impl, tmp}) = Arch.FCOPY
            | query (I.ANNOTATION{i, a}) = query i
            | query _ = undefined ()
       in query instr
       end

   fun defUse {immed, operand} instr = let
          fun undefined () = bug ("defUse", instr)
          fun getOpnd' opnd = 
              (
               case opnd of
               I.IMMED int => immed int
             | _ => operand opnd
              )
          fun getOpnd x = getOpnd' x
          fun getImm i  = immed i
          fun getRegionUse r = RegionProps.readFrom r
          fun getRegionDef r =
          let val (d,u) = RegionProps.writeTo r
          in  d end
          fun withKind(k,l) = l
          fun getCellSet (GP, FP) = (withKind (C.GP, GP)) @ (withKind (C.FP, FP))
          fun query (I.LOADI{li, r, i, t, mem}) = ([t], (getOpnd i)::r::(getRegionUse mem))
            | query (I.LOAD{l, r1, r2, t, mem}) = 
              (
               case l of
               (I.LDWX | I.LDWX_S | I.LDHX | I.LDHX_S | I.LDBX) => ([t], r1::r2::(getRegionUse mem))
             | (I.LDWX_M | I.LDWX_SM | I.LDHX_M | I.LDHX_SM | I.LDBX_M) => ([r1, t], r1::r2::(getRegionUse mem))
              )
            | query (I.STORE{st, b, d, r, mem}) = (getRegionDef mem, [getOpnd d, b, r])
            | query (I.ARITH{a, r1, r2, t}) = ([t], [r1, r2])
            | query (I.ARITHI{ai, i, r, t}) = ([t], [getOpnd i, r])
            | query (I.COMCLR_LDO{cc, r1, r2, t1, i, b, t2}) = (if (t1 = t2)
                 then ([t1], [getImm i, b, r1, r2])
                 else (if (t1 = 0)
                    then ([t2], [getImm i, b, r1, r2, t2])
                    else ([t1, t2], [getImm i, b, r1, r2, t1, t2])))
            | query (I.COMICLR_LDO{cc, i1, r2, t1, i2, b, t2}) = (if (t1 = t2)
                 then ([t1], [getOpnd i1, getImm i2, b, r2])
                 else (if (t1 = 0)
                    then ([t2], [getOpnd i1, getImm i2, b, r2, t2])
                    else ([t1, t2], [getOpnd i1, getImm i2, b, r2, t1, t2])))
            | query (I.SHIFTV{sv, r, len, t}) = ([t], [getImm len, r, 75])
            | query (I.SHIFT{s, r, p, len, t}) = ([t], [getImm len, getImm p, r])
            | query (I.BCOND{cmp, bc, r1, r2, n, nop, t, f}) = ([96], [r1, r2])
            | query (I.BCONDI{cmpi, bc, i, r2, n, nop, t, f}) = ([96], [getImm i, r2])
            | query (I.BB{bc, r, p, n, nop, t, f}) = ([96], [getImm p, r])
            | query (I.B{lab, n}) = ([], [])
            | query (I.LONGJUMP{lab, n, tmp, tmpLab}) = ([], [])
            | query (I.BV{x, b, labs, n}) = ([], [b, x])
            | query (I.BLE{d, b, sr, t, defs, uses, mem}) = (31::((getCellSet defs) @ (getRegionDef mem)), (getOpnd d)::b::((getCellSet uses) @ (getRegionUse mem)))
            | query (I.LDIL{i, t}) = ([t], [getOpnd i])
            | query (I.LDO{i, b, t}) = (if (b = 0)
                 then ([t], [getOpnd i])
                 else ([t], [getOpnd i, b]))
            | query (I.MTCTL{r, t}) = ([t], [r])
            | query (I.FSTORE{fst, b, d, r, mem}) = (getRegionDef mem, [getImm d, b, r])
            | query (I.FSTOREX{fstx, b, x, r, mem}) = 
              (
               case fstx of
               (I.FSTDX | I.FSTDX_S | I.FSTWX | I.FSTWX_S) => (getRegionDef mem, [b, r, x])
             | (I.FSTDX_M | I.FSTDX_SM | I.FSTWX_M | I.FSTWX_SM) => (b::(getRegionDef mem), [b, r, x])
              )
            | query (I.FLOAD{fl, b, d, t, mem}) = ([t], (getImm d)::b::(getRegionUse mem))
            | query (I.FLOADX{flx, b, x, t, mem}) = 
              (
               case flx of
               (I.FLDDX | I.FLDDX_S | I.FLDWX | I.FLDWX_S) => ([t], b::x::(getRegionUse mem))
             | (I.FLDDX_M | I.FLDDX_SM | I.FLDWX_M | I.FLDWX_SM) => ([b, t], b::x::(getRegionUse mem))
              )
            | query (I.FARITH{fa, r1, r2, t}) = ([t], [r1, r2])
            | query (I.FUNARY{fu, f, t}) = ([t], [f])
            | query (I.FCNV{fcnv, f, t}) = ([t], [f])
            | query (I.FBRANCH{cc, fmt, f1, f2, t, f, n, long}) = 
              (
               case cc of
               
               ( I.? |
               I.!<=> |
               I.== |
               I.?= |
               I.!<> |
               I.!?>= |
               I.< |
               I.?< |
               I.!>= |
               I.!?> |
               I.<= |
               I.?<= |
               I.!> |
               I.!?<= |
               I.> |
               I.?> |
               I.!<= |
               I.!?< |
               I.>= |
               I.?>= |
               I.!< |
               I.!?= |
               I.<> |
               I.!= |
               I.!? |
               I.<=> ) => ([], [f1, f2])
             | (I.False_ | I.False | I.EQT | I.NET | I.True_ | I.True) => undefined ()
              )
            | query (I.NOP) = ([], [])
            | query (I.COPY{dst, src, impl, tmp}) = (withKind (C.GP, dst), withKind (C.GP, src))
            | query (I.FCOPY{dst, src, impl, tmp}) = (withKind (C.FP, dst), withKind (C.FP, src))
            | query (I.ANNOTATION{i, a}) = query i
            | query _ = undefined ()
       in query instr
       end

   fun defUseWithCellKind {immed, operand} instr = let
          fun undefined () = bug ("defUseWithCellKind", instr)
          fun getOpnd' opnd = 
              (
               case opnd of
               I.IMMED int => immed int
             | _ => operand opnd
              )
          fun getOpnd x = (getOpnd' x,C.GP)
          fun getImm x  = (immed x,C.GP)
          fun getRegionUse r = 
            map (fn r => (r,C.MEM)) (RegionProps.readFrom r)
          fun getRegionDef r = 
            let val (d,u) = RegionProps.writeTo r
            in  map (fn r => (r,C.MEM)) d end
          fun withKind(k,l) = map (fn x => (x,k)) l
          fun getCellSet (GP, FP) = (withKind (C.GP, GP)) @ (withKind (C.FP, FP))
          fun query (I.LOADI{li, r, i, t, mem}) = ([(t, C.GP)], (getOpnd i)::(r, C.GP)::(getRegionUse mem))
            | query (I.LOAD{l, r1, r2, t, mem}) = 
              (
               case l of
               (I.LDWX | I.LDWX_S | I.LDHX | I.LDHX_S | I.LDBX) => ([(t, C.GP)], (r1, C.GP)::(r2, C.GP)::(getRegionUse mem))
             | (I.LDWX_M | I.LDWX_SM | I.LDHX_M | I.LDHX_SM | I.LDBX_M) => ([(r1, C.GP), (t, C.GP)], (r1, C.GP)::(r2, C.GP)::(getRegionUse mem))
              )
            | query (I.STORE{st, b, d, r, mem}) = (getRegionDef mem, [getOpnd d, (b, C.GP), (r, C.GP)])
            | query (I.ARITH{a, r1, r2, t}) = ([(t, C.GP)], [(r1, C.GP), (r2, C.GP)])
            | query (I.ARITHI{ai, i, r, t}) = ([(t, C.GP)], [getOpnd i, (r, C.GP)])
            | query (I.COMCLR_LDO{cc, r1, r2, t1, i, b, t2}) = (if (t1 = t2)
                 then ([(t1, C.GP)], [getImm i, (b, C.GP), (r1, C.GP), (r2, C.GP)])
                 else (if (t1 = 0)
                    then ([(t2, C.GP)], [getImm i, (b, C.GP), (r1, C.GP), (r2, C.GP), (t2, C.GP)])
                    else ([(t1, C.GP), (t2, C.GP)], [getImm i, (b, C.GP), (r1, C.GP), (r2, C.GP), (t1, C.GP), (t2, C.GP)])))
            | query (I.COMICLR_LDO{cc, i1, r2, t1, i2, b, t2}) = (if (t1 = t2)
                 then ([(t1, C.GP)], [getOpnd i1, getImm i2, (b, C.GP), (r2, C.GP)])
                 else (if (t1 = 0)
                    then ([(t2, C.GP)], [getOpnd i1, getImm i2, (b, C.GP), (r2, C.GP), (t2, C.GP)])
                    else ([(t1, C.GP), (t2, C.GP)], [getOpnd i1, getImm i2, (b, C.GP), (r2, C.GP), (t1, C.GP), (t2, C.GP)])))
            | query (I.SHIFTV{sv, r, len, t}) = ([(t, C.GP)], [getImm len, (r, C.GP), (75, C.CR)])
            | query (I.SHIFT{s, r, p, len, t}) = ([(t, C.GP)], [getImm len, getImm p, (r, C.GP)])
            | query (I.BCOND{cmp, bc, r1, r2, n, nop, t, f}) = ([(96, C.CTRL)], [(r1, C.GP), (r2, C.GP)])
            | query (I.BCONDI{cmpi, bc, i, r2, n, nop, t, f}) = ([(96, C.CTRL)], [getImm i, (r2, C.GP)])
            | query (I.BB{bc, r, p, n, nop, t, f}) = ([(96, C.CTRL)], [getImm p, (r, C.GP)])
            | query (I.B{lab, n}) = ([], [])
            | query (I.LONGJUMP{lab, n, tmp, tmpLab}) = ([], [])
            | query (I.BV{x, b, labs, n}) = ([], [(b, C.GP), (x, C.GP)])
            | query (I.BLE{d, b, sr, t, defs, uses, mem}) = ((31, C.GP)::((getCellSet defs) @ (getRegionDef mem)), (getOpnd d)::(b, C.GP)::((getCellSet uses) @ (getRegionUse mem)))
            | query (I.LDIL{i, t}) = ([(t, C.GP)], [getOpnd i])
            | query (I.LDO{i, b, t}) = (if (b = 0)
                 then ([(t, C.GP)], [getOpnd i])
                 else ([(t, C.GP)], [getOpnd i, (b, C.GP)]))
            | query (I.MTCTL{r, t}) = ([(t, C.CR)], [(r, C.GP)])
            | query (I.FSTORE{fst, b, d, r, mem}) = (getRegionDef mem, [getImm d, (b, C.GP), (r, C.FP)])
            | query (I.FSTOREX{fstx, b, x, r, mem}) = 
              (
               case fstx of
               (I.FSTDX | I.FSTDX_S | I.FSTWX | I.FSTWX_S) => (getRegionDef mem, [(b, C.GP), (r, C.FP), (x, C.GP)])
             | (I.FSTDX_M | I.FSTDX_SM | I.FSTWX_M | I.FSTWX_SM) => ((b, C.GP)::(getRegionDef mem), [(b, C.GP), (r, C.FP), (x, C.GP)])
              )
            | query (I.FLOAD{fl, b, d, t, mem}) = ([(t, C.FP)], (getImm d)::(b, C.GP)::(getRegionUse mem))
            | query (I.FLOADX{flx, b, x, t, mem}) = 
              (
               case flx of
               (I.FLDDX | I.FLDDX_S | I.FLDWX | I.FLDWX_S) => ([(t, C.FP)], (b, C.GP)::(x, C.GP)::(getRegionUse mem))
             | (I.FLDDX_M | I.FLDDX_SM | I.FLDWX_M | I.FLDWX_SM) => ([(b, C.GP), (t, C.FP)], (b, C.GP)::(x, C.GP)::(getRegionUse mem))
              )
            | query (I.FARITH{fa, r1, r2, t}) = ([(t, C.FP)], [(r1, C.FP), (r2, C.FP)])
            | query (I.FUNARY{fu, f, t}) = ([(t, C.FP)], [(f, C.FP)])
            | query (I.FCNV{fcnv, f, t}) = ([(t, C.FP)], [(f, C.FP)])
            | query (I.FBRANCH{cc, fmt, f1, f2, t, f, n, long}) = 
              (
               case cc of
               
               ( I.? |
               I.!<=> |
               I.== |
               I.?= |
               I.!<> |
               I.!?>= |
               I.< |
               I.?< |
               I.!>= |
               I.!?> |
               I.<= |
               I.?<= |
               I.!> |
               I.!?<= |
               I.> |
               I.?> |
               I.!<= |
               I.!?< |
               I.>= |
               I.?>= |
               I.!< |
               I.!?= |
               I.<> |
               I.!= |
               I.!? |
               I.<=> ) => ([], [(f1, C.FP), (f2, C.FP)])
             | (I.False_ | I.False | I.EQT | I.NET | I.True_ | I.True) => undefined ()
              )
            | query (I.NOP) = ([], [])
            | query (I.COPY{dst, src, impl, tmp}) = (withKind (C.GP, dst), withKind (C.GP, src))
            | query (I.FCOPY{dst, src, impl, tmp}) = (withKind (C.FP, dst), withKind (C.FP, src))
            | query (I.ANNOTATION{i, a}) = query i
            | query _ = undefined ()
       in query instr
       end

   local
      val TMP0 = [REG]
      val TMP1 = [FIX, REG]
      val TMP2 = [IMM, REG, REG]
      val TMP3 = [REG, REG]
      val TMP4 = [IMM, REG]
      val TMP5 = [IMM, REG, REG, REG]
      val TMP6 = [FIX]
      val TMP7 = [IMM, REG, REG, REG, FIX]
      val TMP8 = [FIX, FIX]
      val TMP9 = [IMM, REG, REG, REG, FIX, FIX]
      val TMP10 = [IMM, IMM, REG, REG]
      val TMP11 = [IMM, IMM, REG, REG, FIX]
      val TMP12 = [IMM, IMM, REG, REG, FIX, FIX]
      val TMP13 = [IMM, REG, FIX]
      val TMP14 = [IMM, IMM, REG]
      val TMP15 = [CTRL]
      val TMP16 = []
      val TMP17 = [IMM]
      val TMP18 = [REG, REG, REG]
      val TMP19 = [FIX, REG, REG]
   in
      fun opnKind instr = let
             fun undefined () = bug ("opnKind", instr)
             fun REGs rs = map (fn _ => REG) rs
             fun FIXs rs = map (fn _ => FIX) rs
             fun MEMs rs = map (fn _ => MEM) rs
             fun getCellSet (GP, FP) = (FIXs GP) @ (FIXs FP)
             fun getRegionUse r = MEMs (RegionProps.readFrom r)
             fun getRegionDef r = 
             let val (d,u) = RegionProps.writeTo r
             in  MEMs d end
             fun query (I.LOADI{li, r, i, t, mem}) = (TMP0, IMM::REG::(getRegionUse mem))
               | query (I.LOAD{l, r1, r2, t, mem}) = 
                 (
                  case l of
                  (I.LDWX | I.LDWX_S | I.LDHX | I.LDHX_S | I.LDBX) => (TMP0, REG::REG::(getRegionUse mem))
                | (I.LDWX_M | I.LDWX_SM | I.LDHX_M | I.LDHX_SM | I.LDBX_M) => (TMP1, FIX::REG::(getRegionUse mem))
                 )
               | query (I.STORE{st, b, d, r, mem}) = (getRegionDef mem, TMP2)
               | query (I.ARITH{a, r1, r2, t}) = (TMP0, TMP3)
               | query (I.ARITHI{ai, i, r, t}) = (TMP0, TMP4)
               | query (I.COMCLR_LDO{cc, r1, r2, t1, i, b, t2}) = (if (t1 = t2)
                    then (TMP0, TMP5)
                    else (if (t1 = 0)
                       then (TMP6, TMP7)
                       else (TMP8, TMP9)))
               | query (I.COMICLR_LDO{cc, i1, r2, t1, i2, b, t2}) = (if (t1 = t2)
                    then (TMP0, TMP10)
                    else (if (t1 = 0)
                       then (TMP6, TMP11)
                       else (TMP8, TMP12)))
               | query (I.SHIFTV{sv, r, len, t}) = (TMP0, TMP13)
               | query (I.SHIFT{s, r, p, len, t}) = (TMP0, TMP14)
               | query (I.BCOND{cmp, bc, r1, r2, n, nop, t, f}) = (TMP15, TMP3)
               | query (I.BCONDI{cmpi, bc, i, r2, n, nop, t, f}) = (TMP15, TMP4)
               | query (I.BB{bc, r, p, n, nop, t, f}) = (TMP15, TMP4)
               | query (I.B{lab, n}) = (TMP16, TMP16)
               | query (I.LONGJUMP{lab, n, tmp, tmpLab}) = (TMP16, TMP16)
               | query (I.BV{x, b, labs, n}) = (TMP16, TMP3)
               | query (I.BLE{d, b, sr, t, defs, uses, mem}) = (FIX::((getCellSet defs) @ (getRegionDef mem)), IMM::REG::((getCellSet uses) @ (getRegionUse mem)))
               | query (I.LDIL{i, t}) = (TMP0, TMP17)
               | query (I.LDO{i, b, t}) = (if (b = 0)
                    then (TMP0, TMP17)
                    else (TMP0, TMP4))
               | query (I.MTCTL{r, t}) = (TMP6, TMP0)
               | query (I.FSTORE{fst, b, d, r, mem}) = (getRegionDef mem, TMP2)
               | query (I.FSTOREX{fstx, b, x, r, mem}) = 
                 (
                  case fstx of
                  (I.FSTDX | I.FSTDX_S | I.FSTWX | I.FSTWX_S) => (getRegionDef mem, TMP18)
                | (I.FSTDX_M | I.FSTDX_SM | I.FSTWX_M | I.FSTWX_SM) => (FIX::(getRegionDef mem), TMP19)
                 )
               | query (I.FLOAD{fl, b, d, t, mem}) = (TMP0, IMM::REG::(getRegionUse mem))
               | query (I.FLOADX{flx, b, x, t, mem}) = 
                 (
                  case flx of
                  (I.FLDDX | I.FLDDX_S | I.FLDWX | I.FLDWX_S) => (TMP0, REG::REG::(getRegionUse mem))
                | (I.FLDDX_M | I.FLDDX_SM | I.FLDWX_M | I.FLDWX_SM) => (TMP1, FIX::REG::(getRegionUse mem))
                 )
               | query (I.FARITH{fa, r1, r2, t}) = (TMP0, TMP3)
               | query (I.FUNARY{fu, f, t}) = (TMP0, TMP0)
               | query (I.FCNV{fcnv, f, t}) = (TMP0, TMP0)
               | query (I.FBRANCH{cc, fmt, f1, f2, t, f, n, long}) = 
                 (
                  case cc of
                  
                  ( I.? |
                  I.!<=> |
                  I.== |
                  I.?= |
                  I.!<> |
                  I.!?>= |
                  I.< |
                  I.?< |
                  I.!>= |
                  I.!?> |
                  I.<= |
                  I.?<= |
                  I.!> |
                  I.!?<= |
                  I.> |
                  I.?> |
                  I.!<= |
                  I.!?< |
                  I.>= |
                  I.?>= |
                  I.!< |
                  I.!?= |
                  I.<> |
                  I.!= |
                  I.!? |
                  I.<=> ) => (TMP16, TMP3)
                | (I.False_ | I.False | I.EQT | I.NET | I.True_ | I.True) => undefined ()
                 )
               | query (I.NOP) = (TMP16, TMP16)
               | query (I.COPY{dst, src, impl, tmp}) = (REGs dst, REGs src)
               | query (I.FCOPY{dst, src, impl, tmp}) = (REGs dst, REGs src)
               | query (I.ANNOTATION{i, a}) = query i
               | query _ = undefined ()
          in query instr
          end

   end
   fun updateCellKind {update} instr = let
          fun undefined () = bug ("updateCellKind", instr)
          fun enterGP r = update (r, C.GP)
          and enterFP r = update (r, C.FP)
          and enterCR r = update (r, C.CR)
          and enterCC r = update (r, C.CC)
          and enterMEM r = update (r, C.MEM)
          and enterCTRL r = update (r, C.CTRL)
          fun enterCellSet (GP, FP) = app enterFP FP
          fun enterRegionUse r = app enterMEM (RegionProps.readFrom r)
          fun enterRegionDef r = 
          let val (d,u) = RegionProps.writeTo r
          in  app enterMEM d; app enterMEM u end
          fun query (I.LOADI{li, r, i, t, mem}) = enterRegionUse mem
            | query (I.LOAD{l, r1, r2, t, mem}) = enterRegionUse mem
            | query (I.STORE{st, b, d, r, mem}) = enterRegionDef mem
            | query (I.ARITH{a, r1, r2, t}) = ()
            | query (I.ARITHI{ai, i, r, t}) = ()
            | query (I.COMCLR_LDO{cc, r1, r2, t1, i, b, t2}) = ()
            | query (I.COMICLR_LDO{cc, i1, r2, t1, i2, b, t2}) = ()
            | query (I.SHIFTV{sv, r, len, t}) = enterCR 75
            | query (I.SHIFT{s, r, p, len, t}) = ()
            | query (I.BCOND{cmp, bc, r1, r2, n, nop, t, f}) = enterCTRL 96
            | query (I.BCONDI{cmpi, bc, i, r2, n, nop, t, f}) = enterCTRL 96
            | query (I.BB{bc, r, p, n, nop, t, f}) = enterCTRL 96
            | query (I.B{lab, n}) = ()
            | query (I.LONGJUMP{lab, n, tmp, tmpLab}) = ()
            | query (I.BV{x, b, labs, n}) = ()
            | query (I.BLE{d, b, sr, t, defs, uses, mem}) = 
              ( enterCellSet defs; 
              enterRegionDef mem; 
              enterCellSet uses; 
              enterRegionUse mem )
            | query (I.LDIL{i, t}) = ()
            | query (I.LDO{i, b, t}) = ()
            | query (I.MTCTL{r, t}) = enterCR t
            | query (I.FSTORE{fst, b, d, r, mem}) = 
              ( enterRegionDef mem; 
              enterFP r )
            | query (I.FSTOREX{fstx, b, x, r, mem}) = 
              ( enterRegionDef mem; 
              enterFP r )
            | query (I.FLOAD{fl, b, d, t, mem}) = 
              ( enterFP t; 
              enterRegionUse mem )
            | query (I.FLOADX{flx, b, x, t, mem}) = 
              ( enterFP t; 
              enterRegionUse mem )
            | query (I.FARITH{fa, r1, r2, t}) = 
              ( enterFP t; 
              enterFP r1; 
              enterFP r2 )
            | query (I.FUNARY{fu, f, t}) = 
              ( enterFP t; 
              enterFP f )
            | query (I.FCNV{fcnv, f, t}) = 
              ( enterFP t; 
              enterFP f )
            | query (I.FBRANCH{cc, fmt, f1, f2, t, f, n, long}) = 
              (
               case cc of
               
               ( I.? |
               I.!<=> |
               I.== |
               I.?= |
               I.!<> |
               I.!?>= |
               I.< |
               I.?< |
               I.!>= |
               I.!?> |
               I.<= |
               I.?<= |
               I.!> |
               I.!?<= |
               I.> |
               I.?> |
               I.!<= |
               I.!?< |
               I.>= |
               I.?>= |
               I.!< |
               I.!?= |
               I.<> |
               I.!= |
               I.!? |
               I.<=> ) => 
               ( enterFP f1; 
               enterFP f2 )
             | (I.False_ | I.False | I.EQT | I.NET | I.True_ | I.True) => undefined ()
              )
            | query (I.NOP) = ()
            | query (I.COPY{dst, src, impl, tmp}) = ()
            | query (I.FCOPY{dst, src, impl, tmp}) = 
              ( app enterFP dst; 
              app enterFP src )
            | query (I.ANNOTATION{i, a}) = query i
            | query _ = undefined ()
       in query instr
       end

end

