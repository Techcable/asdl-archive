(*
 * This file was automatically generated by MDGen (v2.0)
 * from the machine description file "alpha/alpha.md".
 *)


functor AlphaSSAProps(structure Instr : ALPHAINSTR
                      structure RegionProps : REGION_PROPERTIES 
                      structure RTLProps : RTL_PROPERTIES where I = Instr
                      structure Asm : INSTRUCTION_EMITTER where I = Instr
                      structure OperandTable : OPERAND_TABLE where I = Instr
                        sharing RegionProps.Region = Instr.Region
                      val volatile : Instr.C.cell list
                      val pinnedDef  : Instr.C.cell list
                      val pinnedUse  : Instr.C.cell list
                      val fixedDef   : Instr.C.cell list
                      val fixedUse   : Instr.C.cell list
                     ) : SSA_PROPERTIES =
struct
   structure I        = Instr
   structure C        = I.C
   structure RTLProps = RTLProps
   structure RTL      = RTLProps.RTL
   structure T        = RTL.T
   structure OT       = OperandTable
   structure RP       = RegionProps
   
   datatype const = datatype OT.const
   
   fun error msg = MLRiscErrorMsg.error("AlphaSSAProps",msg)
   
   fun bug(msg,instr) =
   let val Asm.S.STREAM{emit, ...} = Asm.makeStream []
   in  emit (fn r => r) instr; error msg end
   
   val volatile = volatile
   val pinnedDef = pinnedDef
   val pinnedUse = pinnedUse
   val fixedDef  = fixedDef
   val fixedUse  = fixedUse
   val source = I.SOURCE{}
   val sink   = I.SINK{}
   val phi    = I.PHI{}
   
   fun namingConstraints {instr, dst, src} = let
          fun undefined () = bug ("namingConstraints", instr)
          fun cellset(dstsrc,S,C) =
          let val S = C.cellsetToCells S
          in  List.revAppend(ListPair.zip(dstsrc,S),C) end
          fun query (I.DEFFREG FP) = {dst=[], src=[], dstsrc=[]}
            | query (I.LDA{r, b, d}) = {dst=[], src=[], dstsrc=[]}
            | query (I.LDAH{r, b, d}) = {dst=[], src=[], dstsrc=[]}
            | query (I.LOAD{ldOp, r, b, d, mem}) = {dst=[], src=[], dstsrc=[]}
            | query (I.STORE{stOp, r, b, d, mem}) = {dst=[], src=[], dstsrc=[]}
            | query (I.FLOAD{ldOp, r, b, d, mem}) = {dst=[], src=[], dstsrc=[]}
            | query (I.FSTORE{stOp, r, b, d, mem}) = {dst=[], src=[], dstsrc=[]}
            | query (I.JMPL({r, b, d}, label)) = {dst=[], src=[], dstsrc=[]}
            | query (I.JSR{r, b, d, defs, uses, mem}) = 
              (
               case ((), dst, src) of
               ((), _::defsdst, _::usessrc) => {dst=cellset (defsdst, defs, []), src=cellset (usessrc, uses, []), dstsrc=[]}
              )
            | query (I.BSR{r, lab, defs, uses, mem}) = 
              (
               case ((), dst, src) of
               ((), _::defsdst, usessrc) => {dst=cellset (defsdst, defs, []), src=cellset (usessrc, uses, []), dstsrc=[]}
              )
            | query (I.RET{r, b, d}) = {dst=[], src=[], dstsrc=[]}
            | query (I.BRANCH{b, r, lab}) = {dst=[], src=[], dstsrc=[]}
            | query (I.FBRANCH{b, f, lab}) = {dst=[], src=[], dstsrc=[]}
            | query (I.OPERATE{oper, ra, rb, rc}) = {dst=[], src=[], dstsrc=[]}
            | query (I.OPERATEV{oper, ra, rb, rc}) = {dst=[], src=[], dstsrc=[]}
            | query (I.CMOVE{oper, ra, rb, rc}) = {dst=[], src=[], dstsrc=[]}
            | query (I.PSEUDOARITH{oper, ra, rb, rc, tmps}) = 
              (
               case (oper, dst, src) of
               (_, _::tmpsdst, _) => {dst=cellset (tmpsdst, tmps, []), src=[], dstsrc=[]}
              )
            | query (I.COPY{dst, src, impl, tmp}) = {dst=[], src=[], dstsrc=[]}
            | query (I.FCOPY{dst, src, impl, tmp}) = {dst=[], src=[], dstsrc=[]}
            | query (I.FUNARY{oper, fb, fc}) = {dst=[], src=[], dstsrc=[]}
            | query (I.FOPERATE{oper, fa, fb, fc}) = {dst=[], src=[], dstsrc=[]}
            | query (I.FOPERATEV{oper, fa, fb, fc}) = {dst=[], src=[], dstsrc=[]}
            | query (I.FCMOVE{oper, fa, fb, fc}) = {dst=[], src=[], dstsrc=[]}
            | query (I.TRAPB) = {dst=[], src=[], dstsrc=[]}
            | query (I.CALL_PAL{code, def, use}) = {dst=[], src=[], dstsrc=[]}
            | query (I.ANNOTATION{i, a}) = query i
            | query _ = undefined ()
       in query instr
       end

   fun rewriteOperands {const} {instr, dst, src} = let
          fun undefined () = bug ("rewriteOperands", instr)
          fun rwOpnd v =
          if v >= 0 then I.REGop(v)
          else (case const v of
                 OT.OPERAND opnd => opnd
               | OT.IMMED i => I.IMMop(i)
               )
          fun query (I.DEFFREG FP) = 
              (
               case ((), dst, src) of
               ((), [FP'], []) => I.DEFFREG FP'
              )
            | query (I.LDA{r, b, d}) = 
              (
               case ((), dst, src) of
               ((), [r'], [d'', b'']) => I.LDA {r=r', b=b'', d=rwOpnd d''}
              )
            | query (I.LDAH{r, b, d}) = 
              (
               case ((), dst, src) of
               ((), [r'], [d'', b'']) => I.LDAH {r=r', b=b'', d=rwOpnd d''}
              )
            | query (I.LOAD{ldOp, r, b, d, mem}) = 
              (
               case (ldOp, dst, src) of
               (_, [r'], d''::b''::_) => I.LOAD {ldOp=ldOp, r=r', b=b'', d=rwOpnd d'', mem=mem}
              )
            | query (I.STORE{stOp, r, b, d, mem}) = 
              (
               case (stOp, dst, src) of
               (_, _, [d'', b'', r'']) => I.STORE {stOp=stOp, r=r'', b=b'', d=rwOpnd d'', mem=mem}
              )
            | query (I.FLOAD{ldOp, r, b, d, mem}) = 
              (
               case (ldOp, dst, src) of
               (_, [r'], d''::b''::_) => I.FLOAD {ldOp=ldOp, r=r', b=b'', d=rwOpnd d'', mem=mem}
              )
            | query (I.FSTORE{stOp, r, b, d, mem}) = 
              (
               case (stOp, dst, src) of
               (_, _, [d'', b'', r'']) => I.FSTORE {stOp=stOp, r=r'', b=b'', d=rwOpnd d'', mem=mem}
              )
            | query (I.JMPL({r, b, d}, label)) = 
              (
               case ((), dst, src) of
               ((), [r'], [b'']) => I.JMPL ({r=r', b=b'', d=d}, label)
              )
            | query (I.JSR{r, b, d, defs, uses, mem}) = 
              (
               case ((), dst, src) of
               ((), r'::_, b''::_) => I.JSR {r=r', b=b'', d=d, defs=defs, uses=uses, mem=mem}
              )
            | query (I.BSR{r, lab, defs, uses, mem}) = 
              (
               case ((), dst, src) of
               ((), r'::_, _) => I.BSR {r=r', lab=lab, defs=defs, uses=uses, mem=mem}
              )
            | query (I.RET{r, b, d}) = 
              (
               case ((), dst, src) of
               ((), [r'], [b'']) => I.RET {r=r', b=b'', d=d}
              )
            | query (I.BRANCH{b, r, lab}) = 
              (
               case (b, dst, src) of
               (I.BR, [], []) => I.BRANCH {b=b, r=r, lab=lab}
             | ((I.BLBC | I.BEQ | I.BLT | I.BLE | I.BLBS | I.BNE | I.BGE | I.BGT), [], [r'']) => I.BRANCH {b=b, r=r'', lab=lab}
              )
            | query (I.FBRANCH{b, f, lab}) = 
              (
               case (b, dst, src) of
               (_, [], [f'']) => I.FBRANCH {b=b, f=f'', lab=lab}
              )
            | query (I.OPERATE{oper, ra, rb, rc}) = 
              (
               case (oper, dst, src) of
               (_, [rc'], [rb'', ra'']) => I.OPERATE {oper=oper, ra=ra'', rb=rwOpnd rb'', rc=rc'}
              )
            | query (I.OPERATEV{oper, ra, rb, rc}) = 
              (
               case (oper, dst, src) of
               (_, [rc'], [rb'', ra'']) => I.OPERATEV {oper=oper, ra=ra'', rb=rwOpnd rb'', rc=rc'}
              )
            | query (I.CMOVE{oper, ra, rb, rc}) = 
              (
               case (oper, dst, src) of
               (_, [rc'], [rb'', ra'', rc'']) => I.CMOVE {oper=oper, ra=ra'', rb=rwOpnd rb'', rc=rc'}
              )
            | query (I.PSEUDOARITH{oper, ra, rb, rc, tmps}) = 
              (
               case (oper, dst, src) of
               (_, rc'::_, [rb'', ra'']) => I.PSEUDOARITH {oper=oper, ra=ra'', rb=rwOpnd rb'', rc=rc', tmps=tmps}
              )
            | query (I.COPY{dst, src, impl, tmp}) = I.COPY {dst=dst, src=src, impl=impl, tmp=tmp}
            | query (I.FCOPY{dst, src, impl, tmp}) = I.FCOPY {dst=dst, src=src, impl=impl, tmp=tmp}
            | query (I.FUNARY{oper, fb, fc}) = 
              (
               case (oper, dst, src) of
               (_, [fc'], [fb'']) => I.FUNARY {oper=oper, fb=fb'', fc=fc'}
              )
            | query (I.FOPERATE{oper, fa, fb, fc}) = 
              (
               case (oper, dst, src) of
               (_, [fc'], [fa'', fb'']) => I.FOPERATE {oper=oper, fa=fa'', fb=fb'', fc=fc'}
              )
            | query (I.FOPERATEV{oper, fa, fb, fc}) = 
              (
               case (oper, dst, src) of
               (_, [fc'], [fa'', fb'']) => I.FOPERATEV {oper=oper, fa=fa'', fb=fb'', fc=fc'}
              )
            | query (I.FCMOVE{oper, fa, fb, fc}) = 
              (
               case (oper, dst, src) of
               (_, [fc'], [fa'', fb'', fc'']) => I.FCMOVE {oper=oper, fa=fa'', fb=fb'', fc=fc'}
              )
            | query (I.TRAPB) = I.TRAPB 
            | query (I.CALL_PAL{code, def, use}) = I.CALL_PAL {code=code, def=def, use=use}
            | query (I.ANNOTATION{i, a}) = I.ANNOTATION {i=query i, a=a}
            | query _ = undefined ()
       in query instr
       end

   fun copies cps =
   let fun f([],id,is,fd,fs) = (id,is,fd,fs)
         | f({kind,dst,src}::cps,id,is,fd,fs) =
           if dst=src then f(cps,id,is,fd,fs)
           else case kind of
                C.GP   => f(cps,dst::id,src::is,fd,fs)
             |  C.FP   => f(cps,id,is,dst::fd,src::fs)
             |  C.MEM  => f(cps,id,is,fd,fs)
             |  C.CTRL => f(cps,id,is,fd,fs)
             |  _      => error("copies: "^C.cellkindToString kind^
                                " dst="^C.toString kind dst^
                                " src="^C.toString kind src)
    val (id,is,fd,fs) = f(cps,[],[],[],[])
    val icopy = case id of
                  []  => []
                | [_] => [I.COPY{src=is,dst=id,impl=ref NONE,tmp=NONE}]
                | _   => [I.COPY{src=is,dst=id,impl=ref NONE,
                                 tmp=SOME(I.Direct(C.newReg()))}]
    val fcopy = case fd of
                  []  => []
                | [_] => [I.FCOPY{src=fs,dst=fd,impl=ref NONE,tmp=NONE}]
                | _   => [I.FCOPY{src=fs,dst=fd,impl=ref NONE,
                                  tmp=SOME(I.FDirect(C.newFreg()))}]
   in icopy @ fcopy end
   
   fun copy{instr=I.COPY{impl,tmp,...},dst=dst as [_],src} =
           I.COPY{impl=impl,tmp=NONE,dst=dst,src=src}
     | copy{instr=I.COPY{impl,tmp,...},dst,src} =
           I.COPY{impl=impl,tmp=tmp,dst=dst,src=src}
     | copy{instr=I.FCOPY{impl,tmp,...},dst=dst as [_],src} =
           I.FCOPY{impl=impl,tmp=NONE,dst=dst,src=src}
     | copy{instr=I.FCOPY{impl,tmp,...},dst,src} =
           I.FCOPY{impl=impl,tmp=tmp,dst=dst,src=src}
     | copy{instr=I.ANNOTATION{i,a},dst,src} =
           I.ANNOTATION{i=copy{instr=i,dst=dst,src=src},a=a}
     | copy{instr,...} = bug("copy",instr)

(*#line 651.6 "alpha/alpha.md"*)
   fun operand (ty, I.REGop r) = T.REG (ty, r)
     | operand (ty, I.IMMop i) = T.LI i
     | operand (ty, _) = error "operand"
end

