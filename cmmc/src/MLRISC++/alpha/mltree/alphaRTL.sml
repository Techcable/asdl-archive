(*
 * This file was automatically generated by MDGen (v2.0)
 * from the machine description file "alpha/alpha.md".
 *)


functor AlphaRTL(BuildRTL : BUILD_RTL
)= struct
   local
      open BuildRTL
   in

(*#line 4.1 "MD-2.0/basis.md"*)
      structure Basis = struct
      end


(*#line 48.6 "alpha/alpha.md"*)
      open Basis

(*#line 49.6 "alpha/alpha.md"*)
      infix 1 ||

(*#line 50.6 "alpha/alpha.md"*)
      infix 2 :=

(*#line 51.6 "alpha/alpha.md"*)
      infix 3 << >> ~>>

(*#line 53.6 "alpha/alpha.md"*)
      val COPY = (fn {dst, src} => op := 64 (idaggr 64 ( $ ("GP", 64) (forall 5 dst)), fetch 64 (idaggr 64 ( $ ("GP", 64) (forall 5 src))))
                 )

(*#line 54.6 "alpha/alpha.md"*)
      val FCOPY = (fn {dst, src} => op := 64 (idaggr 64 ( $ ("FP", 64) (forall 5 dst)), fetch 64 (idaggr 64 ( $ ("FP", 64) (forall 5 src))))
                  )

(*#line 57.6 "alpha/alpha.md"*)
      fun align4 T105 addr = andb T105 (addr, notb T105 (intConst T105 3))

(*#line 58.6 "alpha/alpha.md"*)
      fun align8 T114 addr = andb T114 (addr, notb T114 (intConst T114 7))

(*#line 59.6 "alpha/alpha.md"*)
      fun align8Upper T123 addr = orb T123 (andb T123 (addr, notb T123 (intConst T123 7)), intConst T123 4)

(*#line 61.6 "alpha/alpha.md"*)
      fun % x = operand 64 x

(*#line 62.6 "alpha/alpha.md"*)
      fun %% l = label 64 l

(*#line 64.6 "alpha/alpha.md"*)
      fun disp (b, d) = op + 64 (fetch 64 (idaggr 64 ( $ ("GP", 64) b)),  % d)

(*#line 66.6 "alpha/alpha.md"*)
      fun byte x = x

(*#line 67.6 "alpha/alpha.md"*)
      fun word x = x

(*#line 68.6 "alpha/alpha.md"*)
      fun dword x = x

(*#line 69.6 "alpha/alpha.md"*)
      fun qword x = x

(*#line 70.6 "alpha/alpha.md"*)
      fun float x = x

(*#line 71.6 "alpha/alpha.md"*)
      fun double x = x

(*#line 73.6 "alpha/alpha.md"*)
      val LDA = (fn {r, b, d} => op := 64 (idaggr 64 ( $ ("GP", 64) r), op + 64 (fetch 64 (idaggr 64 ( $ ("GP", 64) b)),  % d))
                )

(*#line 74.6 "alpha/alpha.md"*)
      val LDAH = (fn {r, b, d} => op := 64 (idaggr 64 ( $ ("GP", 64) r), op << 64 (op + 64 (fetch 64 (idaggr 64 ( $ ("GP", 64) b)),  % d), intConst 64 16))
                 )

(*#line 77.6 "alpha/alpha.md"*)
      val LDB = (fn {r, b, d, mem} => op := 64 (idaggr 64 ( $ ("GP", 64) r), sx (8, 64) (byte (fetch 8 (aggl (8, 8) ( $$ ("MEM", 8) (disp (b, d), mem))))))
                )

(*#line 78.6 "alpha/alpha.md"*)
      val LDW = (fn {r, b, d, mem} => op := 64 (idaggr 64 ( $ ("GP", 64) r), sx (16, 64) (word (fetch 16 (aggl (8, 16) ( $$ ("MEM", 8) (disp (b, d), mem))))))
                )

(*#line 79.6 "alpha/alpha.md"*)
      val LDBU = (fn {r, b, d, mem} => op := 64 (idaggr 64 ( $ ("GP", 64) r), zx (8, 64) (byte (fetch 8 (aggl (8, 8) ( $$ ("MEM", 8) (disp (b, d), mem))))))
                 )

(*#line 80.6 "alpha/alpha.md"*)
      val LDWU = (fn {r, b, d, mem} => op := 64 (idaggr 64 ( $ ("GP", 64) r), zx (16, 64) (word (fetch 16 (aggl (8, 16) ( $$ ("MEM", 8) (disp (b, d), mem))))))
                 )

(*#line 81.6 "alpha/alpha.md"*)
      val LDL = (fn {r, b, d, mem} => op := 64 (idaggr 64 ( $ ("GP", 64) r), sx (32, 64) (dword (fetch 32 (aggl (8, 32) ( $$ ("MEM", 8) (disp (b, d), mem))))))
                )

(*#line 82.6 "alpha/alpha.md"*)
      val LDL_L = (fn {r, b, d, mem} => op := 64 (idaggr 64 ( $ ("GP", 64) r), sx (32, 64) (dword (fetch 32 (aggl (8, 32) ( $$ ("MEM", 8) (align4 64 (disp (b, d)), mem))))))
                  )

(*#line 83.6 "alpha/alpha.md"*)
      val LDQ = (fn {r, b, d, mem} => op := 64 (idaggr 64 ( $ ("GP", 64) r), qword (fetch 64 (aggl (8, 64) ( $$ ("MEM", 8) (disp (b, d), mem)))))
                )

(*#line 84.6 "alpha/alpha.md"*)
      val LDQ_L = (fn {r, b, d, mem} => op := 64 (idaggr 64 ( $ ("GP", 64) r), qword (fetch 64 (aggl (8, 64) ( $$ ("MEM", 8) (align8 64 (disp (b, d)), mem)))))
                  )

(*#line 85.6 "alpha/alpha.md"*)
      val LDQ_U = (fn {r, b, d, mem} => op := 64 (idaggr 64 ( $ ("GP", 64) r), qword (fetch 64 (aggl (8, 64) ( $$ ("MEM", 8) (align8Upper 64 (disp (b, d)), mem)))))
                  )

(*#line 88.6 "alpha/alpha.md"*)
      val STB = (fn {r, b, d, mem} => op := 8 (aggl (8, 8) ( $$ ("MEM", 8) (disp (b, d), mem)), bitslice 64 [(0, 7)] (fetch 64 (idaggr 64 ( $ ("GP", 64) r))))
                )

(*#line 89.6 "alpha/alpha.md"*)
      val STW = (fn {r, b, d, mem} => op := 16 (aggl (8, 16) ( $$ ("MEM", 8) (disp (b, d), mem)), bitslice 64 [(0, 15)] (fetch 64 (idaggr 64 ( $ ("GP", 64) r))))
                )

(*#line 90.6 "alpha/alpha.md"*)
      val STL = (fn {r, b, d, mem} => op := 32 (aggl (8, 32) ( $$ ("MEM", 8) (disp (b, d), mem)), bitslice 64 [(0, 31)] (fetch 64 (idaggr 64 ( $ ("GP", 64) r))))
                )

(*#line 91.6 "alpha/alpha.md"*)
      val STQ = (fn {r, b, d, mem} => op := 64 (aggl (8, 64) ( $$ ("MEM", 8) (disp (b, d), mem)), fetch 64 (idaggr 64 ( $ ("GP", 64) r)))
                )

(*#line 92.6 "alpha/alpha.md"*)
      val STQ_U = (fn {r, b, d, mem} => op := 64 (aggl (8, 64) ( $$ ("MEM", 8) (align8 64 (disp (b, d)), mem)), fetch 64 (idaggr 64 ( $ ("GP", 64) r)))
                  )

(*#line 95.6 "alpha/alpha.md"*)
      val LDF = (fn {r, b, d, mem} => op := 64 (idaggr 64 ( $ ("FP", 64) r), sx (32, 64) (float (fetch 32 (aggl (8, 32) ( $$ ("MEM", 8) (disp (b, d), mem))))))
                )

(*#line 96.6 "alpha/alpha.md"*)
      val LDG = (fn {r, b, d, mem} => op := 64 (idaggr 64 ( $ ("FP", 64) r), double (fetch 64 (aggl (8, 64) ( $$ ("MEM", 8) (disp (b, d), mem)))))
                )

(*#line 97.6 "alpha/alpha.md"*)
      val LDS = (fn {r, b, d, mem} => op := 64 (idaggr 64 ( $ ("FP", 64) r), double (fetch 64 (aggl (8, 64) ( $$ ("MEM", 8) (disp (b, d), mem)))))
                )

(*#line 98.6 "alpha/alpha.md"*)
      val LDT = (fn {r, b, d, mem} => op := 64 (idaggr 64 ( $ ("FP", 64) r), double (fetch 64 (aggl (8, 64) ( $$ ("MEM", 8) (disp (b, d), mem)))))
                )

(*#line 101.6 "alpha/alpha.md"*)
      val STF = (fn {r, b, d, mem} => op := 32 (aggl (8, 32) ( $$ ("MEM", 8) (disp (b, d), mem)), float (sx (64, 32) (fetch 64 (idaggr 64 ( $ ("FP", 64) r)))))
                )

(*#line 102.6 "alpha/alpha.md"*)
      val STG = (fn {r, b, d, mem} => op := 64 (aggl (8, 64) ( $$ ("MEM", 8) (disp (b, d), mem)), fetch 64 (idaggr 64 ( $ ("FP", 64) r)))
                )

(*#line 103.6 "alpha/alpha.md"*)
      val STS = (fn {r, b, d, mem} => op := 64 (aggl (8, 64) ( $$ ("MEM", 8) (disp (b, d), mem)), fetch 64 (idaggr 64 ( $ ("FP", 64) r)))
                )

(*#line 104.6 "alpha/alpha.md"*)
      val STT = (fn {r, b, d, mem} => op := 64 (aggl (8, 64) ( $$ ("MEM", 8) (disp (b, d), mem)), fetch 64 (idaggr 64 ( $ ("FP", 64) r)))
                )

(*#line 107.6 "alpha/alpha.md"*)
      val ADDL = (fn {ra, rb, rc} => op := 64 (idaggr 64 ( $ ("GP", 64) rc), sx (64, 64) (op + 64 (fetch 64 (idaggr 64 ( $ ("GP", 64) ra)),  % rb)))
                 )

(*#line 108.6 "alpha/alpha.md"*)
      val ADDQ = (fn {ra, rb, rc} => op := 64 (idaggr 64 ( $ ("GP", 64) rc), op + 64 (fetch 64 (idaggr 64 ( $ ("GP", 64) ra)),  % rb))
                 )

(*#line 109.6 "alpha/alpha.md"*)
      fun cmp oper {ra, rb, rc} = op := 64 (idaggr 64 ( $ ("GP", 64) rc), cond 64 (oper (fetch 64 (idaggr 64 ( $ ("GP", 64) ra)),  % rb), intConst 64 1, intConst 64 0))

(*#line 111.6 "alpha/alpha.md"*)
      val CMPBGE = cmp (op >= 64)
      and CMPEQ = cmp ( == 64)
      and CMPLE = cmp (op <= 64)
      and CMPLT = cmp (op < 64)
      and CMPULE = cmp (leu 64)
      and CMPULT = cmp (ltu 64)

(*#line 114.6 "alpha/alpha.md"*)
      fun binop oper {ra, rb, rc} = op := 64 (idaggr 64 ( $ ("GP", 64) rc), oper (fetch 64 (idaggr 64 ( $ ("GP", 64) ra)),  % rb))

(*#line 116.6 "alpha/alpha.md"*)
      val SUBL = (fn {ra, rb, rc} => op := 64 (idaggr 64 ( $ ("GP", 64) rc), sx (64, 64) (op - 64 (fetch 64 (idaggr 64 ( $ ("GP", 64) ra)),  % rb)))
                 )

(*#line 117.6 "alpha/alpha.md"*)
      val SUBQ = (fn {ra, rb, rc} => op := 64 (idaggr 64 ( $ ("GP", 64) rc), op - 64 (fetch 64 (idaggr 64 ( $ ("GP", 64) ra)),  % rb))
                 )

(*#line 118.6 "alpha/alpha.md"*)
      val S4ADDL = (fn {ra, rb, rc} => op := 64 (idaggr 64 ( $ ("GP", 64) rc), sx (64, 64) (op << 64 (fetch 64 (idaggr 64 ( $ ("GP", 64) ra)), op + 64 (intConst 64 2,  % rb))))
                   )

(*#line 119.6 "alpha/alpha.md"*)
      val S4ADDQ = (fn {ra, rb, rc} => op := 64 (idaggr 64 ( $ ("GP", 64) rc), op << 64 (fetch 64 (idaggr 64 ( $ ("GP", 64) ra)), op + 64 (intConst 64 2,  % rb)))
                   )

(*#line 120.6 "alpha/alpha.md"*)
      val S4SUBL = (fn {ra, rb, rc} => op := 64 (idaggr 64 ( $ ("GP", 64) rc), sx (64, 64) (op << 64 (fetch 64 (idaggr 64 ( $ ("GP", 64) ra)), op - 64 (intConst 64 2,  % rb))))
                   )

(*#line 121.6 "alpha/alpha.md"*)
      val S4SUBQ = (fn {ra, rb, rc} => op := 64 (idaggr 64 ( $ ("GP", 64) rc), op << 64 (fetch 64 (idaggr 64 ( $ ("GP", 64) ra)), op - 64 (intConst 64 2,  % rb)))
                   )

(*#line 122.6 "alpha/alpha.md"*)
      val S8ADDL = (fn {ra, rb, rc} => op := 64 (idaggr 64 ( $ ("GP", 64) rc), sx (64, 64) (op << 64 (fetch 64 (idaggr 64 ( $ ("GP", 64) ra)), op + 64 (intConst 64 3,  % rb))))
                   )

(*#line 123.6 "alpha/alpha.md"*)
      val S8ADDQ = (fn {ra, rb, rc} => op := 64 (idaggr 64 ( $ ("GP", 64) rc), op << 64 (fetch 64 (idaggr 64 ( $ ("GP", 64) ra)), op + 64 (intConst 64 3,  % rb)))
                   )

(*#line 124.6 "alpha/alpha.md"*)
      val S8SUBL = (fn {ra, rb, rc} => op := 64 (idaggr 64 ( $ ("GP", 64) rc), sx (64, 64) (op << 64 (fetch 64 (idaggr 64 ( $ ("GP", 64) ra)), op - 64 (intConst 64 3,  % rb))))
                   )

(*#line 125.6 "alpha/alpha.md"*)
      val S8SUBQ = (fn {ra, rb, rc} => op := 64 (idaggr 64 ( $ ("GP", 64) rc), op << 64 (fetch 64 (idaggr 64 ( $ ("GP", 64) ra)), op - 64 (intConst 64 3,  % rb)))
                   )

(*#line 126.6 "alpha/alpha.md"*)
      val AND = (fn {ra, rb, rc} => op := 64 (idaggr 64 ( $ ("GP", 64) rc), andb 64 (fetch 64 (idaggr 64 ( $ ("GP", 64) ra)),  % rb))
                )

(*#line 127.6 "alpha/alpha.md"*)
      val BIC = (fn {ra, rb, rc} => op := 64 (idaggr 64 ( $ ("GP", 64) rc), andb 64 (fetch 64 (idaggr 64 ( $ ("GP", 64) ra)), notb 64 ( % rb)))
                )

(*#line 128.6 "alpha/alpha.md"*)
      val BIS = (fn {ra, rb, rc} => op := 64 (idaggr 64 ( $ ("GP", 64) rc), orb 64 (fetch 64 (idaggr 64 ( $ ("GP", 64) ra)),  % rb))
                )

(*#line 129.6 "alpha/alpha.md"*)
      val EQV = (fn {ra, rb, rc} => op := 64 (idaggr 64 ( $ ("GP", 64) rc), eqvb 64 (fetch 64 (idaggr 64 ( $ ("GP", 64) ra)),  % rb))
                )

(*#line 130.6 "alpha/alpha.md"*)
      val ORNOT = (fn {ra, rb, rc} => op := 64 (idaggr 64 ( $ ("GP", 64) rc), orb 64 (fetch 64 (idaggr 64 ( $ ("GP", 64) ra)), notb 64 ( % rb)))
                  )

(*#line 131.6 "alpha/alpha.md"*)
      val XOR = (fn {ra, rb, rc} => op := 64 (idaggr 64 ( $ ("GP", 64) rc), xorb 64 (fetch 64 (idaggr 64 ( $ ("GP", 64) ra)),  % rb))
                )

(*#line 133.6 "alpha/alpha.md"*)
      local
         val newOper = newOp "extbl"
      in
         fun extbl (x0, x1) = newOper [x0, x1]
      end
      local
         val newOper = newOp "extlh"
      in
         fun extlh (x0, x1) = newOper [x0, x1]
      end
      local
         val newOper = newOp "extll"
      in
         fun extll (x0, x1) = newOper [x0, x1]
      end
      local
         val newOper = newOp "extqh"
      in
         fun extqh (x0, x1) = newOper [x0, x1]
      end
      local
         val newOper = newOp "extql"
      in
         fun extql (x0, x1) = newOper [x0, x1]
      end
      local
         val newOper = newOp "extwh"
      in
         fun extwh (x0, x1) = newOper [x0, x1]
      end
      local
         val newOper = newOp "extwl"
      in
         fun extwl (x0, x1) = newOper [x0, x1]
      end
      local
         val newOper = newOp "insbl"
      in
         fun insbl (x0, x1) = newOper [x0, x1]
      end
      local
         val newOper = newOp "inslh"
      in
         fun inslh (x0, x1) = newOper [x0, x1]
      end
      local
         val newOper = newOp "insll"
      in
         fun insll (x0, x1) = newOper [x0, x1]
      end
      local
         val newOper = newOp "insqh"
      in
         fun insqh (x0, x1) = newOper [x0, x1]
      end
      local
         val newOper = newOp "insql"
      in
         fun insql (x0, x1) = newOper [x0, x1]
      end
      local
         val newOper = newOp "inswh"
      in
         fun inswh (x0, x1) = newOper [x0, x1]
      end
      local
         val newOper = newOp "inswl"
      in
         fun inswl (x0, x1) = newOper [x0, x1]
      end
      local
         val newOper = newOp "mskbl"
      in
         fun mskbl (x0, x1) = newOper [x0, x1]
      end
      local
         val newOper = newOp "msklh"
      in
         fun msklh (x0, x1) = newOper [x0, x1]
      end
      local
         val newOper = newOp "mskll"
      in
         fun mskll (x0, x1) = newOper [x0, x1]
      end
      local
         val newOper = newOp "mskqh"
      in
         fun mskqh (x0, x1) = newOper [x0, x1]
      end
      local
         val newOper = newOp "mskql"
      in
         fun mskql (x0, x1) = newOper [x0, x1]
      end
      local
         val newOper = newOp "mskwh"
      in
         fun mskwh (x0, x1) = newOper [x0, x1]
      end
      local
         val newOper = newOp "mskwl"
      in
         fun mskwl (x0, x1) = newOper [x0, x1]
      end

(*#line 136.6 "alpha/alpha.md"*)
      val EXTBL = binop extbl
      and EXTLH = binop extlh
      and EXTLL = binop extll
      and EXTQH = binop extqh
      and EXTQL = binop extql
      and EXTWH = binop extwh
      and EXTWL = binop extwl
      and INSBL = binop insbl
      and INSLH = binop inslh
      and INSLL = binop insll
      and INSQH = binop insqh
      and INSQL = binop insql
      and INSWH = binop inswh
      and INSWL = binop inswl
      and MSKBL = binop mskbl
      and MSKLH = binop msklh
      and MSKLL = binop mskll
      and MSKQH = binop mskqh
      and MSKQL = binop mskql
      and MSKWH = binop mskwh
      and MSKWL = binop mskwl

(*#line 144.6 "alpha/alpha.md"*)
      val SLL = binop (op << 64)
      and SRA = binop (op ~>> 64)
      and SRL = binop (op >> 64)

(*#line 147.6 "alpha/alpha.md"*)
      local
         val newOper = newOp "zap"
      in
         fun zap (x0, x1) = newOper [x0, x1]
      end
      local
         val newOper = newOp "zapnot"
      in
         fun zapnot (x0, x1) = newOper [x0, x1]
      end
      local
         val newOper = newOp "umulh"
      in
         fun umulh (x0, x1) = newOper [x0, x1]
      end

(*#line 148.6 "alpha/alpha.md"*)
      val ZAP = (fn {ra, rb, rc} => op := 64 (idaggr 64 ( $ ("GP", 64) rc), zap (fetch 64 (idaggr 64 ( $ ("GP", 64) ra)),  % rb))
                )

(*#line 149.6 "alpha/alpha.md"*)
      val ZAPNOT = (fn {ra, rb, rc} => op := 64 (idaggr 64 ( $ ("GP", 64) rc), zapnot (fetch 64 (idaggr 64 ( $ ("GP", 64) ra)),  % rb))
                   )

(*#line 150.6 "alpha/alpha.md"*)
      val MULL = (fn {ra, rb, rc} => op := 64 (idaggr 64 ( $ ("GP", 64) rc), sx (64, 64) (muls 64 (fetch 64 (idaggr 64 ( $ ("GP", 64) ra)),  % rb)))
                 )

(*#line 151.6 "alpha/alpha.md"*)
      val MULQ = (fn {ra, rb, rc} => op := 64 (idaggr 64 ( $ ("GP", 64) rc), muls 64 (fetch 64 (idaggr 64 ( $ ("GP", 64) ra)),  % rb))
                 )

(*#line 152.6 "alpha/alpha.md"*)
      val UMULH = (fn {ra, rb, rc} => op := 64 (idaggr 64 ( $ ("GP", 64) rc), umulh (fetch 64 (idaggr 64 ( $ ("GP", 64) ra)),  % rb))
                  )

(*#line 155.6 "alpha/alpha.md"*)
      val overflowtrap = Nop

(*#line 156.6 "alpha/alpha.md"*)
      val ADDLV = (fn {ra, rb, rc} => (ADDL {ra=ra, rb=rb, rc=rc}) || overflowtrap
                  )

(*#line 157.6 "alpha/alpha.md"*)
      val ADDQV = (fn {ra, rb, rc} => (ADDQ {ra=ra, rb=rb, rc=rc}) || overflowtrap
                  )

(*#line 158.6 "alpha/alpha.md"*)
      val SUBLV = (fn {ra, rb, rc} => (SUBL {ra=ra, rb=rb, rc=rc}) || overflowtrap
                  )

(*#line 159.6 "alpha/alpha.md"*)
      val SUBQV = (fn {ra, rb, rc} => (SUBQ {ra=ra, rb=rb, rc=rc}) || overflowtrap
                  )

(*#line 160.6 "alpha/alpha.md"*)
      val MULLV = (fn {ra, rb, rc} => (MULL {ra=ra, rb=rb, rc=rc}) || overflowtrap
                  )

(*#line 161.6 "alpha/alpha.md"*)
      val MULQV = (fn {ra, rb, rc} => (MULQ {ra=ra, rb=rb, rc=rc}) || overflowtrap
                  )

(*#line 163.6 "alpha/alpha.md"*)
      fun lbc T1453 (x, y) = == T1453 (andb T1453 (x, intConst T1453 1), y)

(*#line 164.6 "alpha/alpha.md"*)
      fun lbs T1463 (x, y) = op <> T1463 (andb T1463 (x, intConst T1463 1), y)

(*#line 166.6 "alpha/alpha.md"*)
      val comparisons = [ == 64, lbc 64, lbs 64, op >= 64, op > 64, op <= 64, op < 64, op <> 64]

(*#line 169.6 "alpha/alpha.md"*)
      fun cmov T1489 oper {ra, rb, rc} = If (oper (fetch 64 (idaggr 64 ( $ ("GP", 64) ra)), intConst T1489 0), op := 64 (idaggr 64 ( $ ("GP", 64) rc),  % rb), Nop)

(*#line 171.6 "alpha/alpha.md"*)
      val [CMOVEQ, CMOVLBC, CMOVLBS, CMOVGE, CMOVGT, CMOVLE, CMOVLT, CMOVNE] = map 8 (cmov 64) comparisons

(*#line 175.6 "alpha/alpha.md"*)
      val BR = (fn {lab} => Jmp 64 ( %% lab)
               )

(*#line 176.6 "alpha/alpha.md"*)
      val BSR = (fn {lab, r, defs, uses, mem} => (((Call 64 ( %% lab)) || (op := 64 (idaggr 64 ( $ ("GP", 64) r),  ? 64))) || (op := 64 (idaggr 64 ( $ ("cellset", 0) defs), fetch 64 (idaggr 64 ( $ ("cellset", 0) uses))))) || (op := 8 (aggl (8, 8) ( $$ ("MEM", 8) ( ? 64, mem)), fetch 8 (aggl (8, 8) ( $$ ("MEM", 8) ( ? 64, mem)))))
                )

(*#line 182.6 "alpha/alpha.md"*)
      fun branch T1565 oper {r, lab} = If (oper (fetch 64 (idaggr 64 ( $ ("GP", 64) r)), intConst T1565 0), Jmp 64 ( %% lab), Nop)

(*#line 184.6 "alpha/alpha.md"*)
      val [BEQ, BLBC, BLBS, BGE, BGT, BLE, BLT, BNE] = map 8 (branch 64) comparisons

(*#line 188.6 "alpha/alpha.md"*)
      val DEFFREG = (fn {FP} => op := 64 (idaggr 64 ( $ ("FP", 64) FP),  ? 64)
                    )

(*#line 190.6 "alpha/alpha.md"*)
      val SU = Nop

(*#line 191.6 "alpha/alpha.md"*)
      val SUD = Nop

(*#line 192.6 "alpha/alpha.md"*)
      fun farith oper {fa, fb, fc} = op := 64 (idaggr 64 ( $ ("FP", 64) fc), oper (fetch 64 (idaggr 64 ( $ ("FP", 64) fa)), fetch 64 (idaggr 64 ( $ ("FP", 64) fb))))

(*#line 193.6 "alpha/alpha.md"*)
      fun funary oper {fb, fc} = op := 64 (idaggr 64 ( $ ("FP", 64) fc), oper (fetch 64 (idaggr 64 ( $ ("FP", 64) fb))))

(*#line 194.6 "alpha/alpha.md"*)
      val fops as [ADDS, ADDT, SUBS, SUBT, MULS, MULT, DIVS, DIVT] = map 8 farith [fadd 64, fadd 64, fsub 64, fsub 64, fmul 64, fmul 64, fdiv 64, fdiv 64]

(*#line 197.6 "alpha/alpha.md"*)
      fun su fop {fa, fb, fc} = (fop {fa=fa, fb=fb, fc=fc}) || SU

(*#line 198.6 "alpha/alpha.md"*)
      fun sud fop {fa, fb, fc} = (fop {fa=fa, fb=fb, fc=fc}) || SUD

(*#line 199.6 "alpha/alpha.md"*)
      val [ADDSSU, ADDTSU, SUBSSU, SUBTSU, MULSSU, MULTSU, DIVSSU, DIVTSU] = map 8 su fops

(*#line 201.6 "alpha/alpha.md"*)
      val [ADDSSUD, ADDTSUD, SUBSSUD, SUBTSUD, MULSSUD, MULTSUD, DIVSSUD, DIVTSUD] = map 8 sud fops

(*#line 205.6 "alpha/alpha.md"*)
      local
         val newOper = newOp "cpys"
      in
         fun cpys (x0, x1) = newOper [x0, x1]
      end
      local
         val newOper = newOp "cpyse"
      in
         fun cpyse (x0, x1) = newOper [x0, x1]
      end
      local
         val newOper = newOp "cpysn"
      in
         fun cpysn (x0, x1) = newOper [x0, x1]
      end
      local
         val newOper = newOp "mf_fpcr"
      in
         fun mf_fpcr (x0, x1) = newOper [x0, x1]
      end
      local
         val newOper = newOp "mt_fpcr"
      in
         fun mt_fpcr (x0, x1) = newOper [x0, x1]
      end

(*#line 206.6 "alpha/alpha.md"*)
      val CPYS = farith cpys
      and CPYSE = farith cpyse
      and CPYSN = farith cpysn
      and MF_FPCR = farith mf_fpcr
      and MT_FPCR = farith mt_fpcr

(*#line 209.6 "alpha/alpha.md"*)
      local
         val newOper = newOp "cvtlq"
      in
         fun cvtlq x0 = newOper [x0]
      end
      local
         val newOper = newOp "cvtql"
      in
         fun cvtql x0 = newOper [x0]
      end
      local
         val newOper = newOp "cvtqlsv"
      in
         fun cvtqlsv x0 = newOper [x0]
      end
      local
         val newOper = newOp "cvtqlv"
      in
         fun cvtqlv x0 = newOper [x0]
      end
      local
         val newOper = newOp "cvtqs"
      in
         fun cvtqs x0 = newOper [x0]
      end
      local
         val newOper = newOp "cvtqsc"
      in
         fun cvtqsc x0 = newOper [x0]
      end
      local
         val newOper = newOp "cvtqt"
      in
         fun cvtqt x0 = newOper [x0]
      end
      local
         val newOper = newOp "cvtqtc"
      in
         fun cvtqtc x0 = newOper [x0]
      end
      local
         val newOper = newOp "cvtts"
      in
         fun cvtts x0 = newOper [x0]
      end
      local
         val newOper = newOp "cvttsc"
      in
         fun cvttsc x0 = newOper [x0]
      end
      local
         val newOper = newOp "cvtst"
      in
         fun cvtst x0 = newOper [x0]
      end
      local
         val newOper = newOp "cvtsts"
      in
         fun cvtsts x0 = newOper [x0]
      end
      local
         val newOper = newOp "cvttq"
      in
         fun cvttq x0 = newOper [x0]
      end
      local
         val newOper = newOp "cvttqc"
      in
         fun cvttqc x0 = newOper [x0]
      end

(*#line 213.6 "alpha/alpha.md"*)
      val CVTLQ = funary cvtlq
      and CVTQL = funary cvtql
      and CVTQLSV = funary cvtqlsv
      and CVTQLV = funary cvtqlv
      and CVTQS = funary cvtqs
      and CVTQSC = funary cvtqsc
      and CVTQT = funary cvtqt
      and CVTQTC = funary cvtqtc
      and CVTTS = funary cvtts
      and CVTTSC = funary cvttsc
      and CVTST = funary cvtst
      and CVTSTS = funary cvtsts
      and CVTTQ = funary cvttq
      and CVTTQC = funary cvttqc

(*#line 221.6 "alpha/alpha.md"*)
      local
         val newOper = newOp "teq"
      in
         fun teq (x0, x1) = newOper [x0, x1]
      end
      local
         val newOper = newOp "tlt"
      in
         fun tlt (x0, x1) = newOper [x0, x1]
      end
      local
         val newOper = newOp "tle"
      in
         fun tle (x0, x1) = newOper [x0, x1]
      end
      local
         val newOper = newOp "tun"
      in
         fun tun (x0, x1) = newOper [x0, x1]
      end

(*#line 222.6 "alpha/alpha.md"*)
      val fcmps as [CMPTEQ, CMPTLT, CMPTLE, CMPTUN] = map 4 farith [teq, tlt, tle, tun]

(*#line 224.6 "alpha/alpha.md"*)
      val [CMPTEQSU, CMPTLTSU, CMPTLESU, CMPTUNSU] = map 4 su fcmps

(*#line 228.6 "alpha/alpha.md"*)
      fun fbranch T2032 oper {f, lab} = If (oper (fetch 64 (idaggr 64 ( $ ("FP", 64) f)),  ? T2032), Jmp 64 ( %% lab), Nop)

(*#line 229.6 "alpha/alpha.md"*)
      val FBEQ = fbranch 64 ( |==| 64)
      and FBLT = fbranch 64 ( |<| 64)
      and FBLE = fbranch 64 ( |<=| 64)
      and FBNE = fbranch 64 ( |<>| 64)
      and FBGE = fbranch 64 ( |>=| 64)
      and FBGT = fbranch 64 ( |>| 64)

(*#line 233.6 "alpha/alpha.md"*)
      fun fcmove T2067 cmp {fa, fb, fc} = If (cmp (fetch 64 (idaggr 64 ( $ ("FP", 64) fa)),  ? T2067), op := 64 (idaggr 64 ( $ ("FP", 64) fc), fetch 64 (idaggr 64 ( $ ("FP", 64) fb))), Nop)

(*#line 234.6 "alpha/alpha.md"*)
      val FCMOVEQ = fcmove 64 ( |==| 64)
      and FCMOVLT = fcmove 64 ( |<| 64)
      and FCMOVLE = fcmove 64 ( |<=| 64)
      and FCMOVNE = fcmove 64 ( |<>| 64)
      and FCMOVGE = fcmove 64 ( |>=| 64)
      and FCMOVGT = fcmove 64 ( |>| 64)

(*#line 238.6 "alpha/alpha.md"*)
      val JSR = (fn {r, b, defs, uses, mem} => (((Call 64 (fetch 64 (idaggr 64 ( $ ("GP", 64) b)))) || (op := 64 (idaggr 64 ( $ ("GP", 64) r),  ? 64))) || (op := 64 (idaggr 64 ( $ ("cellset", 0) defs), fetch 64 (idaggr 64 ( $ ("cellset", 0) uses))))) || (op := 8 (aggl (8, 8) ( $$ ("MEM", 8) ( ? 64, mem)), fetch 8 (aggl (8, 8) ( $$ ("MEM", 8) ( ? 64, mem)))))
                )

(*#line 243.6 "alpha/alpha.md"*)
      val RET = (fn {r, b} => (Jmp 64 (fetch 64 (idaggr 64 ( $ ("GP", 64) b)))) || (op := 64 (idaggr 64 ( $ ("GP", 64) r),  ? 64))
                )

(*#line 244.6 "alpha/alpha.md"*)
      val JMPL = (fn {r, b} => (Jmp 64 (fetch 64 (idaggr 64 ( $ ("GP", 64) b)))) || (op := 64 (idaggr 64 ( $ ("GP", 64) r),  ? 64))
                 )

(*#line 245.6 "alpha/alpha.md"*)
      val TRAPB = (fn {} => Nop
                  )

(*#line 248.6 "alpha/alpha.md"*)
      fun pseudoOp oper {ra, rb, rc, tmps} = (op := 64 (idaggr 64 ( $ ("GP", 64) rc), oper (fetch 64 (idaggr 64 ( $ ("GP", 64) ra)),  % rb))) || (op := 64 (idaggr 64 ( $ ("cellset", 0) tmps),  ? 64))

(*#line 251.6 "alpha/alpha.md"*)
      val PSEUDOARITH_DIVL = pseudoOp (divs 64)
      and PSEUDOARITH_DIVLU = pseudoOp (divu 64)
      and PSEUDOARITH_DIVQ = pseudoOp (divs 64)
      and PSEUDOARITH_DIVQU = pseudoOp (divu 64)
      and PSEUDOARITH_REML = pseudoOp (rems 64)
      and PSEUDOARITH_REMLU = pseudoOp (remu 64)
      and PSEUDOARITH_REMQ = pseudoOp (rems 64)
      and PSEUDOARITH_REMQU = pseudoOp (remu 64)

(*#line 259.6 "alpha/alpha.md"*)
      local
         val newOper = newOp "BPT"
      in
         fun BPT x0 = newOper [x0]
      end
      local
         val newOper = newOp "BUGCHK"
      in
         fun BUGCHK x0 = newOper [x0]
      end
      local
         val newOper = newOp "CALLSYS"
      in
         fun CALLSYS x0 = newOper [x0]
      end
      local
         val newOper = newOp "GENTRAP"
      in
         fun GENTRAP x0 = newOper [x0]
      end
      local
         val newOper = newOp "IMB"
      in
         fun IMB x0 = newOper [x0]
      end
      local
         val newOper = newOp "RDUNIQUE"
      in
         fun RDUNIQUE x0 = newOper [x0]
      end
      local
         val newOper = newOp "WRUNIQUE"
      in
         fun WRUNIQUE x0 = newOper [x0]
      end

(*#line 260.6 "alpha/alpha.md"*)
      fun CALL_PAL code {def, use} = (Call 64 (qword (code (qword (intConst 64 0))))) || (op := 64 (idaggr 64 ( $ ("GP", 64) (forall 5 def)), fetch 64 (idaggr 64 ( $ ("GP", 64) (forall 5 use)))))

(*#line 263.6 "alpha/alpha.md"*)
      val CALL_PAL_BPT = CALL_PAL BPT
      and CALL_PAL_BUGCHK = CALL_PAL BUGCHK
      and CALL_PAL_CALLSYS = CALL_PAL CALLSYS
      and CALL_PAL_GENTRAP = CALL_PAL GENTRAP
      and CALL_PAL_IMB = CALL_PAL IMB
      and CALL_PAL_RDUNIQUE = CALL_PAL RDUNIQUE
      and CALL_PAL_WRUNIQUE = CALL_PAL WRUNIQUE
   end
end

