(*
 * This file was automatically generated by MDGen (v2.0)
 * from the machine description file "alpha/alpha.md".
 *)


functor AlphaSchedProps(structure Instr : ALPHAINSTR
                        structure RegionProps : REGION_PROPERTIES
                        structure Asm   : INSTRUCTION_EMITTER where I = Instr
                          sharing RegionProps.Region = Instr.Region
                       ) : SCHEDULING_PROPERTIES =
struct
   structure I = Instr
   structure C = I.C
   
   type latency = int
   type time = int
   type architecture = string
   
   exception AlphaStructuralHazard
   exception StructuralHazard = AlphaStructuralHazard
   fun error msg = MLRiscErrorMsg.error("AlphaSchedProps",msg)
   
   fun bug(msg,instr) =
   let val Asm.S.STREAM{emit, ...} = Asm.makeStream []
   in  emit (fn r => r) instr; error msg end
   
   val source = I.SOURCE{}
   val sink   = I.SINK{}
   
   structure A = DynArray
   type state = int
   type reservation_table = (state * I.instruction list) A.array
   fun newTableDefault{n, backward} = A.array(n,(0,[]))
   fun defUseDefault instr = let
          fun undefined () = bug ("defUseDefault", instr)
          fun getOpnd (opnd, rest) = 
              (
               case opnd of
               I.REGop GP => GP::rest
             | _ => rest
              )
          fun mkSet set = map (fn r => (r,0)) set
          fun getRegionDef r = 
          let val (d,u) = RegionProps.writeTo r
          in  map (fn r => (r,~1)) d end
          fun getRegionUse r = RegionProps.readFrom r
          fun getCellSetDef (GP, FP) = (mkSet GP) @ (mkSet FP)
          fun getCellSetUse (GP, FP) = GP @ FP
          fun query (I.DEFFREG FP) = ([(FP, 0)], [])
            | query (I.LDA{r, b, d}) = ([(r, 0)], getOpnd (d, [b]))
            | query (I.LDAH{r, b, d}) = ([(r, 0)], getOpnd (d, [b]))
            | query (I.LOAD{ldOp, r, b, d, mem}) = ([(r, 1)], getOpnd (d, b::(getRegionUse mem)))
            | query (I.STORE{stOp, r, b, d, mem}) = (getRegionDef mem, getOpnd (d, [b, r]))
            | query (I.FLOAD{ldOp, r, b, d, mem}) = ([(r, 1)], getOpnd (d, b::(getRegionUse mem)))
            | query (I.FSTORE{stOp, r, b, d, mem}) = (getRegionDef mem, getOpnd (d, [b, r]))
            | query (I.JMPL({r, b, d}, label)) = ([(r, 0)], [b])
            | query (I.JSR{r, b, d, defs, uses, mem}) = ((r, 0)::((getCellSetDef defs) @ (getRegionDef mem)), b::((getCellSetUse uses) @ (getRegionUse mem)))
            | query (I.BSR{r, lab, defs, uses, mem}) = ((r, 0)::((getCellSetDef defs) @ (getRegionDef mem)), (getCellSetUse uses) @ (getRegionUse mem))
            | query (I.RET{r, b, d}) = ([(r, 0)], [b])
            | query (I.BRANCH{b, r, lab}) = 
              (
               case b of
               I.BR => ([], [])
             | (I.BLBC | I.BEQ | I.BLT | I.BLE | I.BLBS | I.BNE | I.BGE | I.BGT) => ([], [r])
              )
            | query (I.FBRANCH{b, f, lab}) = ([], [f])
            | query (I.OPERATE{oper, ra, rb, rc}) = ([(rc, 0)], getOpnd (rb, [ra]))
            | query (I.OPERATEV{oper, ra, rb, rc}) = ([(rc, 0)], getOpnd (rb, [ra]))
            | query (I.CMOVE{oper, ra, rb, rc}) = ([(rc, 0)], getOpnd (rb, [ra, rc]))
            | query (I.PSEUDOARITH{oper, ra, rb, rc, tmps}) = ((rc, 0)::(getCellSetDef tmps), getOpnd (rb, [ra]))
            | query (I.COPY{dst, src, impl, tmp}) = (mkSet dst, src)
            | query (I.FCOPY{dst, src, impl, tmp}) = (mkSet dst, src)
            | query (I.FUNARY{oper, fb, fc}) = ([(fc, 0)], [fb])
            | query (I.FOPERATE{oper, fa, fb, fc}) = ([(fc, 0)], [fa, fb])
            | query (I.FOPERATEV{oper, fa, fb, fc}) = ([(fc, 0)], [fa, fb])
            | query (I.FCMOVE{oper, fa, fb, fc}) = ([(fc, 0)], [fa, fb, fc])
            | query (I.TRAPB) = ([], [])
            | query (I.CALL_PAL{code, def, use}) = (mkSet def, use)
            | query (I.ANNOTATION{i, a}) = query i
            | query _ = undefined ()
       in query instr
       end

   fun insertAfterDefault(rt, time, instr) = 
   let fun loop(t) = 
       let val (state, _) = A.sub(rt, t)
       in  if state >= 1 then loop(t+1) else t (* XXX *)
       end
       val index = loop(time)
       val (state, instrs) = A.sub(rt, index)
       val newState = state+1
       val newInstrs = instr::instrs
   in  A.update(rt, index, (newState, newInstrs)); time end
   fun insertBeforeDefault(rt, time, instr) = 
   let val index = ~time
       val (state, instrs) = A.sub(rt, index)
       val newState = state
       val newInstrs = instr::instrs
   in  A.update(rt, index, (newState, newInstrs)); time end
   fun linearizeDefault{table, backward} = 
     if backward then
        A.foldr (fn ((_,instrs),l) => List.revAppend(instrs,l)) [] table
     else
        A.foldl (fn ((_,instrs),l) => instrs @ l) [] table
   fun info arch = {newTable=newTableDefault, defUse=defUseDefault, insertAfter=insertAfterDefault, insertBefore=insertBeforeDefault, linearize=linearizeDefault}
   structure Shuffle = Shuffle(I)
   fun move{src=I.Direct rs,dst=I.Direct rd} =
        [I.COPY{src=[rs], dst=[rd], tmp=NONE, impl=ref NONE}]
   fun fmove{src=I.FDirect rs,dst=I.FDirect rd} =
        [I.FCOPY{src=[rs], dst=[rd], tmp=NONE, impl=ref NONE}]
   val shuffle = Shuffle.shuffle{mvInstr=move, ea=I.Direct}
   val shufflefp = Shuffle.shuffle{mvInstr=fmove, ea=I.FDirect}
   fun splitCopies regmap =
   let fun f(I.ANNOTATION{i,...}) = f i
         | f(I.COPY{src,dst,tmp,...}) =
             shuffle{regmap=regmap, tmp=tmp, src=src, dst=dst}
         | f(I.FCOPY{src,dst,tmp,...}) =
             shufflefp{regmap=regmap, tmp=tmp, src=src, dst=dst}
         | f i = [i]
   in  f end
end

