(*
 * This file was automatically generated by MDGen (v2.0)
 * from the machine description file "mips/mips.md".
 *)


functor MIPSAsmEmitter(structure Instr : MIPSINSTR
                       structure Stream : INSTRUCTION_STREAM
                       structure Shuffle : MIPSSHUFFLE
                          where I = Instr
                      ) : INSTRUCTION_EMITTER =
struct
   structure I  = Instr
   structure C  = I.C
   structure S  = Stream
   structure P  = S.P
   structure LabelExp = I.LabelExp
   structure Constant = I.Constant
   
   val show_cellset = MLRiscControl.getFlag "asm-show-cellset"
   val show_region  = MLRiscControl.getFlag "asm-show-region"
   val indent_copies = MLRiscControl.getFlag "asm-indent-copies"
   
   fun error msg = MLRiscErrorMsg.error("MIPSAsmEmitter",msg)
   
   fun makeStream formatAnnotations =
   let val stream = !AsmStream.asmOutStream
       fun emit' s = TextIO.output(stream,s)
       val newline = ref true
       val tabs = ref 0
       fun tabbing 0 = ()
         | tabbing n = (emit' "\t"; tabbing(n-1))
       fun emit s = (tabbing(!tabs); tabs := 0; newline := false; emit' s)
       fun nl() = (tabs := 0; if !newline then () else (newline := true; emit' "\n"))
       fun comma() = emit ","
       fun tab() = tabs := 1
       fun indent() = tabs := 2
       fun ms n = let val s = Int.toString n
                  in  if n<0 then "-"^String.substring(s,1,size s-1)
                      else s
                  end
       fun emit_label lab = emit(Label.nameOf lab)
       fun emit_labexp le = emit(LabelExp.toString le)
       fun emit_const c = emit(Constant.toString c)
       fun emit_int i = emit(ms i)
       fun paren f = (emit "("; f(); emit ")")
       fun defineLabel lab = emit(Label.nameOf lab^":\n")
       fun entryLabel lab = defineLabel lab
       fun comment msg = (tab(); emit("/* " ^ msg ^ " */"))
       fun annotation a = (comment(Annotations.toString a); nl())
       fun doNothing _ = ()
       fun emit_region mem = comment(I.Region.toString mem)
       val emit_region = 
          if !show_region then emit_region else doNothing
       fun pseudoOp pOp = emit(P.toString pOp)
       fun init size = (comment("Code Size = " ^ ms size); nl())
       fun emitter regmap =
       let
           val emitRegInfo = AsmFormatUtil.reginfo
                                (emit,regmap,formatAnnotations)
   fun emit_GP r = 
       ( emit (C.showGP (regmap r)); 
       emitRegInfo r )
   and emit_FP r = 
       ( emit (C.showFP (regmap r)); 
       emitRegInfo r )
   and emit_CC r = 
       ( emit (C.showCC (regmap r)); 
       emitRegInfo r )
   and emit_HI r = 
       ( emit (C.showHI (regmap r)); 
       emitRegInfo r )
   and emit_LO r = 
       ( emit (C.showLO (regmap r)); 
       emitRegInfo r )
   and emit_MEM r = 
       ( emit (C.showMEM (regmap r)); 
       emitRegInfo r )
   and emit_CTRL r = 
       ( emit (C.showCTRL (regmap r)); 
       emitRegInfo r )
   
       fun emit_cellset(title,cellset) =
         (nl(); comment(title^C.cellsetToString' regmap cellset))
       val emit_cellset = 
         if !show_cellset then emit_cellset else doNothing
       fun emit_defs cellset = emit_cellset("defs: ",cellset)
       fun emit_uses cellset = emit_cellset("uses: ",cellset)
   fun asm_load (I.LD) = "ld"
     | asm_load (I.LW) = "lw"
     | asm_load (I.LH) = "lh"
     | asm_load (I.LHU) = "lhu"
     | asm_load (I.LB) = "lb"
     | asm_load (I.LBU) = "lbu"
     | asm_load (I.LWL) = "lwl"
     | asm_load (I.LWR) = "lwr"
     | asm_load (I.LWU) = "lwu"
     | asm_load (I.LDL) = "ldl"
     | asm_load (I.LDR) = "ldr"
     | asm_load (I.ULH) = "ulh"
     | asm_load (I.ULHU) = "ulhu"
     | asm_load (I.ULW) = "ulw"
     | asm_load (I.ULD) = "uld"
   and emit_load x = emit (asm_load x)
   and asm_store (I.SD) = "sd"
     | asm_store (I.SW) = "sw"
     | asm_store (I.SH) = "sh"
     | asm_store (I.SB) = "sb"
     | asm_store (I.SWL) = "swl"
     | asm_store (I.SWR) = "swr"
     | asm_store (I.SDL) = "sdl"
     | asm_store (I.SDR) = "sdr"
     | asm_store (I.USH) = "ush"
     | asm_store (I.USW) = "usw"
     | asm_store (I.USD) = "usd"
   and emit_store x = emit (asm_store x)
   and asm_fload (I.L_D) = "l.d"
     | asm_fload (I.L_S) = "l.s"
     | asm_fload (I.LDXC1) = "ldxc1"
     | asm_fload (I.LWXC1) = "lwxc1"
   and emit_fload x = emit (asm_fload x)
   and asm_fstore (I.S_D) = "s.d"
     | asm_fstore (I.S_S) = "s.s"
     | asm_fstore (I.SDXC1) = "sdxc1"
     | asm_fstore (I.SWXC1) = "swxc1"
   and emit_fstore x = emit (asm_fstore x)
   and asm_fcond (I.UN) = "un"
     | asm_fcond (I.EQ) = "eq"
     | asm_fcond (I.UEQ) = "ueq"
     | asm_fcond (I.OLT) = "olt"
     | asm_fcond (I.ULT) = "ult"
     | asm_fcond (I.OLE) = "ole"
     | asm_fcond (I.ULE) = "ule"
     | asm_fcond (I.NGLE) = "ngle"
     | asm_fcond (I.NGL) = "ngl"
     | asm_fcond (I.LT) = "lt"
     | asm_fcond (I.NGE) = "nge"
     | asm_fcond (I.LE) = "le"
     | asm_fcond (I.NGT) = "ngt"
   and emit_fcond x = emit (asm_fcond x)
   and asm_arith (I.ADD) = "add"
     | asm_arith (I.ADDU) = "addu"
     | asm_arith (I.AND) = "and"
     | asm_arith (I.XOR) = "xor"
     | asm_arith (I.MUL) = "mul"
     | asm_arith (I.MULO) = "mulo"
     | asm_arith (I.MULOU) = "mulou"
     | asm_arith (I.NOR) = "nor"
     | asm_arith (I.OR) = "or"
     | asm_arith (I.SEQ) = "seq"
     | asm_arith (I.SGT) = "sgt"
     | asm_arith (I.SGE) = "sge"
     | asm_arith (I.SGEU) = "sgeu"
     | asm_arith (I.SGTU) = "sgtu"
     | asm_arith (I.SLT) = "slt"
     | asm_arith (I.SLE) = "sle"
     | asm_arith (I.SLEU) = "sleu"
     | asm_arith (I.SLTU) = "sltu"
     | asm_arith (I.SNE) = "sne"
     | asm_arith (I.SUB) = "sub"
     | asm_arith (I.SUBU) = "subu"
     | asm_arith (I.REM) = "rem"
     | asm_arith (I.REMU) = "remu"
     | asm_arith (I.SRA) = "sra"
     | asm_arith (I.SLL) = "sll"
     | asm_arith (I.SRL) = "srl"
     | asm_arith (I.ROR) = "ror"
     | asm_arith (I.ROL) = "rol"
     | asm_arith (I.MOVN) = "movn"
     | asm_arith (I.MOVZ) = "movz"
     | asm_arith (I.DADD) = "dadd"
     | asm_arith (I.DADDU) = "daddu"
     | asm_arith (I.DMUL) = "dmul"
     | asm_arith (I.DMULO) = "dmulo"
     | asm_arith (I.DMULOU) = "dmulou"
     | asm_arith (I.DSUB) = "dsub"
     | asm_arith (I.DSUBU) = "dsubu"
     | asm_arith (I.DREM) = "drem"
     | asm_arith (I.DREMU) = "dremu"
     | asm_arith (I.DROL) = "drol"
     | asm_arith (I.DROR) = "dror"
     | asm_arith (I.DSRA) = "dsra"
     | asm_arith (I.DSLL) = "dsll"
     | asm_arith (I.DSRL) = "dsrl"
   and emit_arith x = emit (asm_arith x)
   and asm_unary (I.ABS) = "abs"
     | asm_unary (I.NEG) = "neg"
     | asm_unary (I.NEGU) = "negu"
     | asm_unary (I.NOT) = "not"
     | asm_unary (I.DABS) = "dabs"
     | asm_unary (I.DNEG) = "dneg"
     | asm_unary (I.DNEGU) = "dnegu"
   and emit_unary x = emit (asm_unary x)
   and asm_multiply (I.MULT) = "mult"
     | asm_multiply (I.MULTU) = "multu"
     | asm_multiply (I.DMULT) = "dmult"
     | asm_multiply (I.DMULTU) = "dmultu"
   and emit_multiply x = emit (asm_multiply x)
   and asm_divide (I.DIV) = "div"
     | asm_divide (I.DIVU) = "divu"
     | asm_divide (I.DDIV) = "ddiv"
     | asm_divide (I.DDIVU) = "ddivu"
   and emit_divide x = emit (asm_divide x)
   and asm_trap (I.TEQ) = "teq"
     | asm_trap (I.TNE) = "tne"
     | asm_trap (I.TLT) = "tlt"
     | asm_trap (I.TLTU) = "tltu"
     | asm_trap (I.TGE) = "tge"
     | asm_trap (I.TGEU) = "tgeu"
   and emit_trap x = emit (asm_trap x)
   and asm_farith (I.ADD_D) = "add.d"
     | asm_farith (I.ADD_S) = "add.s"
     | asm_farith (I.SUB_D) = "sub.d"
     | asm_farith (I.SUB_S) = "sub.s"
     | asm_farith (I.MUL_D) = "mul.d"
     | asm_farith (I.MUL_S) = "mul.s"
     | asm_farith (I.DIV_D) = "div.d"
     | asm_farith (I.DIV_S) = "div.s"
   and emit_farith x = emit (asm_farith x)
   and asm_funary (I.ABS_D) = "abs.d"
     | asm_funary (I.ABS_S) = "abs.s"
     | asm_funary (I.CVT_SD) = "cvt.s.d"
     | asm_funary (I.CVT_SW) = "cvt.s.w"
     | asm_funary (I.CVT_DS) = "cvt.d.s"
     | asm_funary (I.CVT_DW) = "cvt.d.w"
     | asm_funary (I.CVT_WS) = "cvt.w.s"
     | asm_funary (I.CVT_WD) = "cvt.w.d"
     | asm_funary (I.CVT_SL) = "cvt.s.l"
     | asm_funary (I.CVT_DL) = "cvt.d.l"
     | asm_funary (I.CVT_LS) = "cvt.l.s"
     | asm_funary (I.CVT_LD) = "cvt.l.d"
   and emit_funary x = emit (asm_funary x)
   and asm_farith3 (I.MADD_D) = "madd.d"
     | asm_farith3 (I.MADD_S) = "madd.s"
     | asm_farith3 (I.NMADD_D) = "nmadd.d"
     | asm_farith3 (I.NMADD_S) = "nmadd.s"
     | asm_farith3 (I.MSUB_D) = "msub.d"
     | asm_farith3 (I.MSUB_S) = "msub.s"
     | asm_farith3 (I.NMSUB_D) = "nmsub.d"
     | asm_farith3 (I.NMSUB_S) = "nmsub.s"
   and emit_farith3 x = emit (asm_farith3 x)
   and asm_fround (I.TRUNC_WS) = "trunc.w.s"
     | asm_fround (I.TRUNC_WD) = "trunc.w.d"
     | asm_fround (I.ROUND_WS) = "round.w.d"
     | asm_fround (I.ROUND_WD) = "round.w.d"
     | asm_fround (I.CEIL_WD) = "ceil.w.d"
     | asm_fround (I.CEIL_WS) = "ceil.w.s"
     | asm_fround (I.CEILU_WD) = "ceilu.w.d"
     | asm_fround (I.CEILU_WS) = "ceilu.w.s"
     | asm_fround (I.FLOOR_WD) = "floor.w.d"
     | asm_fround (I.FLOOR_WS) = "floor.w.s"
     | asm_fround (I.FLOORU_WD) = "flooru.w.d"
     | asm_fround (I.FLOORU_WS) = "flooru.w.s"
     | asm_fround (I.ROUNDU_WD) = "roundu.w.d"
     | asm_fround (I.ROUNDU_WS) = "roundu.w.s"
     | asm_fround (I.TRUNCU_WD) = "truncu.w.d"
     | asm_fround (I.TRUNCU_WS) = "truncu.w.s"
     | asm_fround (I.TRUNC_LS) = "trunc.l.s"
     | asm_fround (I.TRUNC_LD) = "trunc.l.d"
     | asm_fround (I.ROUND_LS) = "round.l.s"
     | asm_fround (I.ROUND_LD) = "round.l.d"
     | asm_fround (I.CEIL_LS) = "ceil.l.s"
     | asm_fround (I.CEIL_LD) = "ceil.l.d"
     | asm_fround (I.FLOOR_LS) = "floor.l.s"
     | asm_fround (I.FLOOR_LD) = "floor.l.d"
   and emit_fround x = emit (asm_fround x)
   and asm_fmt (I.SINGLE) = "s"
     | asm_fmt (I.DOUBLE) = "d"
   and emit_fmt x = emit (asm_fmt x)
   and emit_operand (I.Imm int) = emit_int int
     | emit_operand (I.Reg GP) = emit_GP GP
     | emit_operand (I.Lab labexp) = emit_labexp labexp
     | emit_operand (I.HiLab labexp) = 
       ( emit "$hi("; 
       emit_labexp labexp; 
       emit ")" )
     | emit_operand (I.LoLab labexp) = 
       ( emit "$lo("; 
       emit_labexp labexp; 
       emit ")" )
   fun emitInstr' instr = 
       (
        case instr of
        I.NOP => emit "nop"
      | I.LA{rd, b, d} => 
        ( emit "la\t"; 
        emit_GP rd; 
        emit ", "; 
        emit_GP b; 
        emit ", "; 
        emit_operand d )
      | I.DLA{rd, b, d} => 
        ( emit "dla\t"; 
        emit_GP rd; 
        emit ", "; 
        emit_GP b; 
        emit ", "; 
        emit_operand d )
      | I.LOAD{l, rd, b, d, mem} => 
        ( emit_load l; 
        emit "\t"; 
        emit_GP rd; 
        emit ", "; 
        emit_operand d; 
        emit "("; 
        emit_GP b; 
        emit ")"; 
        emit_region mem )
      | I.STORE{s, rs, b, d, mem} => 
        ( emit_store s; 
        emit "\t"; 
        emit_GP rs; 
        emit ", "; 
        emit_operand d; 
        emit "("; 
        emit_GP b; 
        emit ")"; 
        emit_region mem )
      | I.FLOAD{l, fd, b, d, mem} => 
        ( emit_fload l; 
        emit "\t"; 
        emit_FP fd; 
        emit ", "; 
        emit_operand d; 
        emit "("; 
        emit_GP b; 
        emit ")"; 
        emit_region mem )
      | I.FSTORE{s, fs, b, d, mem} => 
        ( emit_fstore s; 
        emit "\t"; 
        emit_GP fs; 
        emit ", "; 
        emit_operand d; 
        emit "("; 
        emit_GP b; 
        emit ")"; 
        emit_region mem )
      | I.FCMP{cond, fmt, fs1, fs2} => 
        ( emit "c."; 
        emit_fcond cond; 
        emit "."; 
        emit_fmt fmt; 
        emit "\t"; 
        emit_FP fs1; 
        emit ", "; 
        emit_FP fs2 )
      | I.TRAP{t, rs, i} => 
        ( emit_trap t; 
        emit "\t"; 
        emit_GP rs; 
        emit ", "; 
        emit_operand i )
      | I.JUMP GP => emit "jump"
      | I.BEQ(bool, GP1, GP2, operand) => emit "beq"
      | I.BCOP1(bool, operand) => emit "bcop1"
      | I.SETBASEADDR(operand, GP) => emit "setbaseaddr"
      | I.LOADF(FP, operand, int, GP) => emit "loadf"
      | I.BRANCH(bool, GP1, GP2, operand1, GP3, operand2) => emit "branch"
      | I.BRANCH_COP1(bool, operand1, GP, operand2) => emit "branch_cop1"
      | I.ARITH{oper, rd, rs, i} => 
        ( emit_arith oper; 
        emit "\t"; 
        emit_GP rd; 
        emit ", "; 
        emit_GP rs; 
        emit ", "; 
        emit_operand i )
      | I.UNARY{oper, rd, rs} => 
        ( emit_unary oper; 
        emit "\t"; 
        emit_GP rd; 
        emit ", "; 
        emit_GP rs )
      | I.MULTIPLY{oper, rd, rs} => 
        ( emit_multiply oper; 
        emit "\t"; 
        emit_GP rd; 
        emit ", "; 
        emit_GP rs )
      | I.DIVIDE{oper, rd, rs} => 
        ( emit_divide oper; 
        emit "\t"; 
        emit_GP rd; 
        emit ", "; 
        emit_GP rs )
      | I.MFLO GP => 
        ( emit "mflo\t"; 
        emit_GP GP )
      | I.MTLO GP => 
        ( emit "mtlo\t"; 
        emit_GP GP )
      | I.MFHI GP => 
        ( emit "mfhi\t"; 
        emit_GP GP )
      | I.MTHI GP => 
        ( emit "mthi\t"; 
        emit_GP GP )
      | I.BREAK int => 
        ( emit "break\t"; 
        emit_int int )
      | I.FARITH{oper, fd, fs1, fs2} => 
        ( emit_farith oper; 
        emit "\t"; 
        emit_FP fd; 
        emit ", "; 
        emit_FP fs1; 
        emit ", "; 
        emit_FP fs2 )
      | I.FUNARY{oper, fd, fs} => 
        ( emit_funary oper; 
        emit "\t"; 
        emit_FP fd; 
        emit ", "; 
        emit_FP fs )
      | I.FARITH3{oper, fd, fs1, fs2, fs3} => 
        ( emit_farith3 oper; 
        emit "\t"; 
        emit_FP fd; 
        emit ", "; 
        emit_FP fs1; 
        emit ", "; 
        emit_FP fs2; 
        emit ", "; 
        emit_FP fs3 )
      | I.FROUND{oper, fd, fs1, rs2} => 
        ( emit_fround oper; 
        emit "\t"; 
        emit_FP fd; 
        emit ", "; 
        emit_FP fs1; 
        emit ", "; 
        emit_FP fs1; 
        emit ", "; 
        emit_GP rs2 )
      | I.MTC1(GP1, GP2) => emit "mtc1"
      | I.LWC1(GP1, GP2, operand) => emit "lwc1"
      | I.SWC1(GP1, GP2, operand) => emit "swc1"
      | I.LUI(GP, operand) => emit "lui"
      | I.LDC1(GP1, GP2, operand) => emit "ldc1"
      | I.SDC1(GP1, GP2, operand) => emit "sdc1"
      | I.COPY{dst, src, impl, tmp} => emitInstrs (Shuffle.shuffle {regmap=regmap, tmp=tmp, src=src, dst=dst})
      | I.FCOPY{dst, src, impl, tmp} => emitInstrs (Shuffle.shufflefp {regmap=regmap, tmp=tmp, src=src, dst=dst})
      | I.ANNOTATION{i, a} => 
        ( comment (Annotations.toString a); 
        nl (); 
        emitInstr i )
      | I.PHI{} => emit "phi"
      | I.SOURCE{} => emit "source"
      | I.SINK{} => emit "sink"
       )
          and emitInstr i = (tab(); emitInstr' i; nl())
          and emitInstrIndented i = (indent(); emitInstr' i; nl())
          and emitInstrs instrs =
           app (if !indent_copies then emitInstrIndented
                else emitInstr) instrs
      in  emitInstr end
   
   in  S.STREAM{beginCluster=init,
                pseudoOp=pseudoOp,
                emit=emitter,
                endCluster=doNothing,
                defineLabel=defineLabel,
                entryLabel=entryLabel,
                comment=comment,
                exitBlock=doNothing,
                annotation=annotation,
                phi=doNothing,
                alias=doNothing
               }
   end
end

