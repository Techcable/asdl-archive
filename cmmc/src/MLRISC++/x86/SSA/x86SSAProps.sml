(*
 * This file was automatically generated by MDGen (v2.0)
 * from the machine description file "x86/x86.md".
 *)


functor X86SSAProps(structure Instr : X86INSTR
                    structure RegionProps : REGION_PROPERTIES 
                    structure RTLProps : RTL_PROPERTIES where I = Instr
                    structure Asm : INSTRUCTION_EMITTER where I = Instr
                    structure OperandTable : OPERAND_TABLE where I = Instr
                      sharing RegionProps.Region = Instr.Region
                    val volatile : Instr.C.cell list
                    val pinnedDef  : Instr.C.cell list
                    val pinnedUse  : Instr.C.cell list
                    val fixedDef   : Instr.C.cell list
                    val fixedUse   : Instr.C.cell list
                   ) : SSA_PROPERTIES =
struct
   structure I        = Instr
   structure C        = I.C
   structure RTLProps = RTLProps
   structure RTL      = RTLProps.RTL
   structure T        = RTL.T
   structure OT       = OperandTable
   structure RP       = RegionProps
   
   datatype const = datatype OT.const
   
   fun error msg = MLRiscErrorMsg.error("X86SSAProps",msg)
   
   fun bug(msg,instr) =
   let val Asm.S.STREAM{emit, ...} = Asm.makeStream []
   in  emit (fn r => r) instr; error msg end
   
   val volatile = volatile
   val pinnedDef = pinnedDef
   val pinnedUse = pinnedUse
   val fixedDef  = fixedDef
   val fixedUse  = fixedUse
   val source = I.SOURCE{}
   val sink   = I.SINK{}
   val phi    = I.PHI{}
   
   fun namingConstraints {instr, dst, src} = let
          fun undefined () = bug ("namingConstraints", instr)
          fun cellset(dstsrc,S,C) =
          let val S = C.cellsetToCells S
          in  List.revAppend(ListPair.zip(dstsrc,S),C) end
          fun query _ = undefined ()
       in query instr
       end

   fun rewriteOperands {const} {instr, dst, src} = let
          fun undefined () = bug ("rewriteOperands", instr)
          fun rwOpnd v =
          if v >= 0 then error "rwOpnd"(v)
          else (case const v of
                 OT.OPERAND opnd => opnd
               | OT.IMMED i => error "rwOpnd"(i)
               )
          fun query _ = undefined ()
       in query instr
       end

   fun copies cps =
   let fun f([],id,is,fd,fs) = (id,is,fd,fs)
         | f({kind,dst,src}::cps,id,is,fd,fs) =
           if dst=src then f(cps,id,is,fd,fs)
           else case kind of
                C.GP   => f(cps,dst::id,src::is,fd,fs)
             |  C.FP   => f(cps,id,is,dst::fd,src::fs)
             |  C.MEM  => f(cps,id,is,fd,fs)
             |  C.CTRL => f(cps,id,is,fd,fs)
             |  _      => error("copies: "^C.cellkindToString kind^
                                " dst="^C.toString kind dst^
                                " src="^C.toString kind src)
    val (id,is,fd,fs) = f(cps,[],[],[],[])
    val icopy = case id of
                  []  => []
                | [_] => [I.COPY{src=is,dst=id,tmp=NONE}]
                | _   => [I.COPY{src=is,dst=id,
                                 tmp=SOME(I.Direct(C.newReg()))}]
    val fcopy = case fd of
                  []  => []
                | [_] => [I.FCOPY{src=fs,dst=fd,tmp=NONE}]
                | _   => [I.FCOPY{src=fs,dst=fd,
                                  tmp=SOME(I.FDirect(C.newFreg()))}]
   in icopy @ fcopy end
   
   fun copy{instr=I.COPY{tmp,...},dst=dst as [_],src} =
           I.COPY{tmp=NONE,dst=dst,src=src}
     | copy{instr=I.COPY{tmp,...},dst,src} =
           I.COPY{tmp=tmp,dst=dst,src=src}
     | copy{instr=I.FCOPY{tmp,...},dst=dst as [_],src} =
           I.FCOPY{tmp=NONE,dst=dst,src=src}
     | copy{instr=I.FCOPY{tmp,...},dst,src} =
           I.FCOPY{tmp=tmp,dst=dst,src=src}
     | copy{instr=I.ANNOTATION{i,a},dst,src} =
           I.ANNOTATION{i=copy{instr=i,dst=dst,src=src},a=a}
     | copy{instr,...} = bug("copy",instr)

(*#line 533.8 "x86/x86.md"*)
   fun operand (ty, I.Immed i) = T.LI (Int32.toInt i)
     | operand (ty, I.Direct r) = T.REG (ty, r)
     | operand _ = error "operand"
end

