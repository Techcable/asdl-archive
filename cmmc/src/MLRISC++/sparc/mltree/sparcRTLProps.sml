(*
 * This file was automatically generated by MDGen (v2.0)
 * from the machine description file "sparc/sparc.md".
 *)


functor SparcRTLProps(structure Instr : SPARCINSTR
                      structure RegionProps : REGION_PROPERTIES
                      structure Asm : INSTRUCTION_EMITTER where I = Instr
                        sharing Instr.Region = RegionProps.Region
                     ) : RTL_PROPERTIES =
struct
   structure I   = Instr
   structure C   = I.C
   structure RTL = MLTreeRTL
   structure T   = RTL.T
   
   datatype opnkind =
     IMM     (* a constant operand *)
   | REG     (* can be renamed *)
   | FIX     (* cannot be renamed *)
   | MEM     (* memory *)
   | CTRL    (* control dependence *)
   
   fun error msg = MLRiscErrorMsg.error("SparcRTLProps",msg)
   
   fun bug(msg,instr) =
   let val Asm.S.STREAM{emit, ...} = Asm.makeStream []
   in  emit (fn r => r) instr; error msg end
   
   structure SparcRTL = SparcRTL(BuildRTL)
   structure Arch = struct
      local
         val TMP0 = T.REG (64, 0)
         val TMP1 = T.REG (32, 0)
         val TMP2 = T.REG (64, 1)
         val TMP3 = T.REG (0, 2)
         val TMP4 = T.REG (64, 2)
         val TMP5 = T.REG (0, 0)
         val TMP6 = T.REXT (64, RTL.PARAM (0, 1))
         val TMP7 = T.REG (32, 1)
         val TMP8 = T.REXT (32, RTL.PARAM (0, 0))
         val TMP9 = T.REG (0, 1)
         val TMP10 = T.REXT (0, RTL.PARAM (2, 3))
         val TMP11 = T.REXT (0, RTL.PARAM (1, 1))
      in
         val COPY = RTL.new (SparcRTL.COPY {dst=TMP0, src=TMP0})
         val FCOPY = RTL.new (SparcRTL.FCOPY {dst=TMP1, src=TMP1})
         val RDY = RTL.new (SparcRTL.RDY {d=TMP0})
         val WRY = RTL.new (SparcRTL.WRY {r=TMP2, i=TMP0})
         val SETHI = RTL.new (SparcRTL.SETHI {i=TMP0, d=TMP0})
         val LDSB = RTL.new (SparcRTL.LDSB {r=TMP2, i=TMP0, d=TMP0, mem=TMP3})
         val LDSH = RTL.new (SparcRTL.LDSH {r=TMP2, i=TMP0, d=TMP0, mem=TMP3})
         val LDUB = RTL.new (SparcRTL.LDUB {r=TMP2, i=TMP0, d=TMP0, mem=TMP3})
         val LDUH = RTL.new (SparcRTL.LDUH {r=TMP2, i=TMP0, d=TMP0, mem=TMP3})
         val LD = RTL.new (SparcRTL.LD {r=TMP2, i=TMP0, d=TMP0, mem=TMP3})
         val LDX = RTL.new (SparcRTL.LDX {r=TMP2, i=TMP0, d=TMP0, mem=TMP3})
         val STB = RTL.new (SparcRTL.STB {r=TMP4, i=TMP0, d=TMP2, mem=TMP5})
         val STH = RTL.new (SparcRTL.STH {r=TMP4, i=TMP0, d=TMP2, mem=TMP5})
         val ST = RTL.new (SparcRTL.ST {r=TMP4, i=TMP0, d=TMP2, mem=TMP5})
         val STX = RTL.new (SparcRTL.STX {r=TMP4, i=TMP0, d=TMP2, mem=TMP5})
         val li = RTL.new (SparcRTL.li {i=TMP0, d=TMP0})
         val AND = RTL.new (SparcRTL.AND {r=TMP2, i=TMP0, d=TMP0})
         val ANDN = RTL.new (SparcRTL.ANDN {r=TMP2, i=TMP0, d=TMP0})
         val OR = RTL.new (SparcRTL.OR {r=TMP2, i=TMP0, d=TMP0})
         val ORN = RTL.new (SparcRTL.ORN {r=TMP2, i=TMP0, d=TMP0})
         val XOR = RTL.new (SparcRTL.XOR {r=TMP2, i=TMP0, d=TMP0})
         val XNOR = RTL.new (SparcRTL.XNOR {r=TMP2, i=TMP0, d=TMP0})
         val ANDCC = RTL.new (SparcRTL.ANDCC {r=TMP2, i=TMP0, d=TMP0})
         val ANDNCC = RTL.new (SparcRTL.ANDNCC {r=TMP2, i=TMP0, d=TMP0})
         val ORCC = RTL.new (SparcRTL.ORCC {r=TMP2, i=TMP0, d=TMP0})
         val ORNCC = RTL.new (SparcRTL.ORNCC {r=TMP2, i=TMP0, d=TMP0})
         val XORCC = RTL.new (SparcRTL.XORCC {r=TMP2, i=TMP0, d=TMP0})
         val XNORCC = RTL.new (SparcRTL.XNORCC {r=TMP2, i=TMP0, d=TMP0})
         val ADD = RTL.new (SparcRTL.ADD {r=TMP2, i=TMP0, d=TMP0})
         val TADD = RTL.new (SparcRTL.TADD {r=TMP2, i=TMP0, d=TMP0})
         val TADDTV = RTL.new (SparcRTL.TADDTV {r=TMP2, i=TMP0, d=TMP0})
         val SUB = RTL.new (SparcRTL.SUB {r=TMP2, i=TMP0, d=TMP0})
         val TSUB = RTL.new (SparcRTL.TSUB {r=TMP2, i=TMP0, d=TMP0})
         val TSUBTV = RTL.new (SparcRTL.TSUBTV {r=TMP2, i=TMP0, d=TMP0})
         val ADDCC = RTL.new (SparcRTL.ADDCC {r=TMP2, i=TMP0, d=TMP0})
         val TADDCC = RTL.new (SparcRTL.TADDCC {r=TMP2, i=TMP0, d=TMP0})
         val TADDTVCC = RTL.new (SparcRTL.TADDTVCC {r=TMP2, i=TMP0, d=TMP0})
         val SUBCC = RTL.new (SparcRTL.SUBCC {r=TMP2, i=TMP0, d=TMP0})
         val TSUBCC = RTL.new (SparcRTL.TSUBCC {r=TMP2, i=TMP0, d=TMP0})
         val TSUBTVCC = RTL.new (SparcRTL.TSUBTVCC {r=TMP2, i=TMP0, d=TMP0})
         val UMUL = RTL.new (SparcRTL.UMUL {r=TMP2, i=TMP0, d=TMP0})
         val SMUL = RTL.new (SparcRTL.SMUL {r=TMP2, i=TMP0, d=TMP0})
         val UMULCC = RTL.new (SparcRTL.UMULCC {r=TMP2, i=TMP0, d=TMP0})
         val SMULCC = RTL.new (SparcRTL.SMULCC {r=TMP2, i=TMP0, d=TMP0})
         val UDIV = RTL.new (SparcRTL.UDIV {r=TMP2, i=TMP0, d=TMP0})
         val SDIV = RTL.new (SparcRTL.SDIV {r=TMP2, i=TMP0, d=TMP0})
         val UDIVCC = RTL.new (SparcRTL.UDIVCC {r=TMP2, i=TMP0, d=TMP0})
         val SDIVCC = RTL.new (SparcRTL.SDIVCC {r=TMP2, i=TMP0, d=TMP0})
         val MULX = RTL.new (SparcRTL.MULX {r=TMP2, i=TMP0, d=TMP0})
         val SDIVX = RTL.new (SparcRTL.SDIVX {r=TMP2, i=TMP0, d=TMP0})
         val UDIVX = RTL.new (SparcRTL.UDIVX {r=TMP2, i=TMP0, d=TMP0})
         val SLL = RTL.new (SparcRTL.SLL {r=TMP2, i=TMP0, d=TMP0})
         val SRL = RTL.new (SparcRTL.SRL {r=TMP2, i=TMP0, d=TMP0})
         val SRA = RTL.new (SparcRTL.SRA {r=TMP2, i=TMP0, d=TMP0})
         val SLLX = RTL.new (SparcRTL.SLLX {r=TMP2, i=TMP0, d=TMP0})
         val SRLX = RTL.new (SparcRTL.SRLX {r=TMP2, i=TMP0, d=TMP0})
         val SRAX = RTL.new (SparcRTL.SRAX {r=TMP2, i=TMP0, d=TMP0})
         val BN = RTL.new (SparcRTL.BN {label=TMP5})
         val BE = RTL.new (SparcRTL.BE {label=TMP5})
         val BLE = RTL.new (SparcRTL.BLE {label=TMP5})
         val BL = RTL.new (SparcRTL.BL {label=TMP5})
         val BLEU = RTL.new (SparcRTL.BLEU {label=TMP5})
         val BCS = RTL.new (SparcRTL.BCS {label=TMP5})
         val BNEG = RTL.new (SparcRTL.BNEG {label=TMP5})
         val BVS = RTL.new (SparcRTL.BVS {label=TMP5})
         val BA = RTL.new (SparcRTL.BA {label=TMP5})
         val BNE = RTL.new (SparcRTL.BNE {label=TMP5})
         val BG = RTL.new (SparcRTL.BG {label=TMP5})
         val BGE = RTL.new (SparcRTL.BGE {label=TMP5})
         val BGU = RTL.new (SparcRTL.BGU {label=TMP5})
         val BCC = RTL.new (SparcRTL.BCC {label=TMP5})
         val BPOS = RTL.new (SparcRTL.BPOS {label=TMP5})
         val BVC = RTL.new (SparcRTL.BVC {label=TMP5})
         val JMP = RTL.new (SparcRTL.JMP {r=TMP2, i=TMP0})
         val MOVRZ = RTL.new (SparcRTL.MOVRZ {r=TMP4, i=TMP0, d=TMP6})
         val MOVRLEZ = RTL.new (SparcRTL.MOVRLEZ {r=TMP4, i=TMP0, d=TMP6})
         val MOVRLZ = RTL.new (SparcRTL.MOVRLZ {r=TMP4, i=TMP0, d=TMP6})
         val MOVRNZ = RTL.new (SparcRTL.MOVRNZ {r=TMP4, i=TMP0, d=TMP6})
         val MOVRGZ = RTL.new (SparcRTL.MOVRGZ {r=TMP4, i=TMP0, d=TMP6})
         val MOVRGEZ = RTL.new (SparcRTL.MOVRGEZ {r=TMP4, i=TMP0, d=TMP6})
         val LDF = RTL.new (SparcRTL.LDF {r=TMP2, i=TMP0, d=TMP1, mem=TMP3})
         val LDDF = RTL.new (SparcRTL.LDDF {r=TMP2, i=TMP0, d=TMP1, mem=TMP3})
         val LDQF = RTL.new (SparcRTL.LDQF {r=TMP2, i=TMP0, d=TMP1, mem=TMP3})
         val STF = RTL.new (SparcRTL.STF {r=TMP4, i=TMP0, d=TMP7, mem=TMP5})
         val STDF = RTL.new (SparcRTL.STDF {r=TMP4, i=TMP0, d=TMP7, mem=TMP5})
         val LDFSR = RTL.new (SparcRTL.LDFSR {r=TMP2, i=TMP0, mem=TMP3})
         val LDXFSR = RTL.new (SparcRTL.LDXFSR {r=TMP2, i=TMP0, mem=TMP3})
         val STFSR = RTL.new (SparcRTL.STFSR {r=TMP2, i=TMP0, mem=TMP5})
         val FiTOs = RTL.new (SparcRTL.FiTOs {r=TMP1, d=TMP1})
         val FiTOd = RTL.new (SparcRTL.FiTOd {r=TMP1, d=TMP1})
         val FiTOq = RTL.new (SparcRTL.FiTOq {r=TMP1, d=TMP1})
         val FsTOi = RTL.new (SparcRTL.FsTOi {r=TMP1, d=TMP1})
         val FdTOi = RTL.new (SparcRTL.FdTOi {r=TMP1, d=TMP1})
         val FqTOi = RTL.new (SparcRTL.FqTOi {r=TMP1, d=TMP1})
         val FsTOd = RTL.new (SparcRTL.FsTOd {r=TMP1, d=TMP1})
         val FsTOq = RTL.new (SparcRTL.FsTOq {r=TMP1, d=TMP1})
         val FdTOs = RTL.new (SparcRTL.FdTOs {r=TMP1, d=TMP1})
         val FdTOq = RTL.new (SparcRTL.FdTOq {r=TMP1, d=TMP1})
         val FqTOs = RTL.new (SparcRTL.FqTOs {r=TMP1, d=TMP1})
         val FqTOd = RTL.new (SparcRTL.FqTOd {r=TMP1, d=TMP1})
         val FMOVs = RTL.new (SparcRTL.FMOVs {r=TMP1, d=TMP1})
         val FNEGs = RTL.new (SparcRTL.FNEGs {r=TMP1, d=TMP1})
         val FABSs = RTL.new (SparcRTL.FABSs {r=TMP1, d=TMP1})
         val FMOVd = RTL.new (SparcRTL.FMOVd {r=TMP1, d=TMP1})
         val FNEGd = RTL.new (SparcRTL.FNEGd {r=TMP1, d=TMP1})
         val FABSd = RTL.new (SparcRTL.FABSd {r=TMP1, d=TMP1})
         val FMOVq = RTL.new (SparcRTL.FMOVq {r=TMP1, d=TMP1})
         val FNEGq = RTL.new (SparcRTL.FNEGq {r=TMP1, d=TMP1})
         val FABSq = RTL.new (SparcRTL.FABSq {r=TMP1, d=TMP1})
         val FSQRTs = RTL.new (SparcRTL.FSQRTs {r=TMP1, d=TMP1})
         val FSQRTd = RTL.new (SparcRTL.FSQRTd {r=TMP1, d=TMP1})
         val FSQRTq = RTL.new (SparcRTL.FSQRTq {r=TMP1, d=TMP1})
         val FADDs = RTL.new (SparcRTL.FADDs {r1=TMP1, r2=TMP7, d=TMP1})
         val FADDd = RTL.new (SparcRTL.FADDd {r1=TMP1, r2=TMP7, d=TMP1})
         val FADDq = RTL.new (SparcRTL.FADDq {r1=TMP1, r2=TMP7, d=TMP1})
         val FSUBs = RTL.new (SparcRTL.FSUBs {r1=TMP1, r2=TMP7, d=TMP1})
         val FSUBd = RTL.new (SparcRTL.FSUBd {r1=TMP1, r2=TMP7, d=TMP1})
         val FSUBq = RTL.new (SparcRTL.FSUBq {r1=TMP1, r2=TMP7, d=TMP1})
         val FMULs = RTL.new (SparcRTL.FMULs {r1=TMP1, r2=TMP7, d=TMP1})
         val FMULd = RTL.new (SparcRTL.FMULd {r1=TMP1, r2=TMP7, d=TMP1})
         val FMULq = RTL.new (SparcRTL.FMULq {r1=TMP1, r2=TMP7, d=TMP1})
         val FsMULd = RTL.new (SparcRTL.FsMULd {r1=TMP1, r2=TMP7, d=TMP1})
         val FdMULq = RTL.new (SparcRTL.FdMULq {r1=TMP1, r2=TMP7, d=TMP1})
         val FDIVs = RTL.new (SparcRTL.FDIVs {r1=TMP1, r2=TMP7, d=TMP1})
         val FDIVd = RTL.new (SparcRTL.FDIVd {r1=TMP1, r2=TMP7, d=TMP1})
         val FDIVq = RTL.new (SparcRTL.FDIVq {r1=TMP1, r2=TMP7, d=TMP1})
         val FCMPs = RTL.new (SparcRTL.FCMPs {r1=TMP1, r2=TMP7})
         val FCMPd = RTL.new (SparcRTL.FCMPd {r1=TMP1, r2=TMP7})
         val FCMPq = RTL.new (SparcRTL.FCMPq {r1=TMP1, r2=TMP7})
         val FCMPEs = RTL.new (SparcRTL.FCMPEs {r1=TMP1, r2=TMP7})
         val FCMPEd = RTL.new (SparcRTL.FCMPEd {r1=TMP1, r2=TMP7})
         val FCMPEq = RTL.new (SparcRTL.FCMPEq {r1=TMP1, r2=TMP7})
         val FBN = RTL.new (SparcRTL.FBN {label=TMP5})
         val FBNE = RTL.new (SparcRTL.FBNE {label=TMP5})
         val FBLG = RTL.new (SparcRTL.FBLG {label=TMP5})
         val FBUL = RTL.new (SparcRTL.FBUL {label=TMP5})
         val FBL = RTL.new (SparcRTL.FBL {label=TMP5})
         val FBUG = RTL.new (SparcRTL.FBUG {label=TMP5})
         val FBG = RTL.new (SparcRTL.FBG {label=TMP5})
         val FBU = RTL.new (SparcRTL.FBU {label=TMP5})
         val FBA = RTL.new (SparcRTL.FBA {label=TMP5})
         val FBE = RTL.new (SparcRTL.FBE {label=TMP5})
         val FBUE = RTL.new (SparcRTL.FBUE {label=TMP5})
         val FBGE = RTL.new (SparcRTL.FBGE {label=TMP5})
         val FBUGE = RTL.new (SparcRTL.FBUGE {label=TMP5})
         val FBLE = RTL.new (SparcRTL.FBLE {label=TMP5})
         val FBULE = RTL.new (SparcRTL.FBULE {label=TMP5})
         val FBO = RTL.new (SparcRTL.FBO {label=TMP5})
         val MOVN = RTL.new (SparcRTL.MOVN {i=TMP0, d=TMP6})
         val MOVNE = RTL.new (SparcRTL.MOVNE {i=TMP0, d=TMP6})
         val MOVLG = RTL.new (SparcRTL.MOVLG {i=TMP0, d=TMP6})
         val MOVUL = RTL.new (SparcRTL.MOVUL {i=TMP0, d=TMP6})
         val MOVL = RTL.new (SparcRTL.MOVL {i=TMP0, d=TMP6})
         val MOVUG = RTL.new (SparcRTL.MOVUG {i=TMP0, d=TMP6})
         val MOVG = RTL.new (SparcRTL.MOVG {i=TMP0, d=TMP6})
         val MOVU = RTL.new (SparcRTL.MOVU {i=TMP0, d=TMP6})
         val MOVA = RTL.new (SparcRTL.MOVA {i=TMP0, d=TMP6})
         val MOVE = RTL.new (SparcRTL.MOVE {i=TMP0, d=TMP6})
         val MOVUE = RTL.new (SparcRTL.MOVUE {i=TMP0, d=TMP6})
         val MOVGE = RTL.new (SparcRTL.MOVGE {i=TMP0, d=TMP6})
         val MOVUGE = RTL.new (SparcRTL.MOVUGE {i=TMP0, d=TMP6})
         val MOVLE = RTL.new (SparcRTL.MOVLE {i=TMP0, d=TMP6})
         val MOVULE = RTL.new (SparcRTL.MOVULE {i=TMP0, d=TMP6})
         val MOVO = RTL.new (SparcRTL.MOVO {i=TMP0, d=TMP6})
         val FMOVN = RTL.new (SparcRTL.FMOVN {r=TMP7, d=TMP8})
         val FMOVNE = RTL.new (SparcRTL.FMOVNE {r=TMP7, d=TMP8})
         val FMOVLG = RTL.new (SparcRTL.FMOVLG {r=TMP7, d=TMP8})
         val FMOVUL = RTL.new (SparcRTL.FMOVUL {r=TMP7, d=TMP8})
         val FMOVL = RTL.new (SparcRTL.FMOVL {r=TMP7, d=TMP8})
         val FMOVUG = RTL.new (SparcRTL.FMOVUG {r=TMP7, d=TMP8})
         val FMOVG = RTL.new (SparcRTL.FMOVG {r=TMP7, d=TMP8})
         val FMOVU = RTL.new (SparcRTL.FMOVU {r=TMP7, d=TMP8})
         val FMOVA = RTL.new (SparcRTL.FMOVA {r=TMP7, d=TMP8})
         val FMOVE = RTL.new (SparcRTL.FMOVE {r=TMP7, d=TMP8})
         val FMOVUE = RTL.new (SparcRTL.FMOVUE {r=TMP7, d=TMP8})
         val FMOVGE = RTL.new (SparcRTL.FMOVGE {r=TMP7, d=TMP8})
         val FMOVUGE = RTL.new (SparcRTL.FMOVUGE {r=TMP7, d=TMP8})
         val FMOVLE = RTL.new (SparcRTL.FMOVLE {r=TMP7, d=TMP8})
         val FMOVULE = RTL.new (SparcRTL.FMOVULE {r=TMP7, d=TMP8})
         val FMOVO = RTL.new (SparcRTL.FMOVO {r=TMP7, d=TMP8})
         val TICCBN = RTL.new (SparcRTL.TICCBN {r=TMP2, i=TMP0})
         val TICCBE = RTL.new (SparcRTL.TICCBE {r=TMP2, i=TMP0})
         val TICCBLE = RTL.new (SparcRTL.TICCBLE {r=TMP2, i=TMP0})
         val TICCBL = RTL.new (SparcRTL.TICCBL {r=TMP2, i=TMP0})
         val TICCBLEU = RTL.new (SparcRTL.TICCBLEU {r=TMP2, i=TMP0})
         val TICCBCS = RTL.new (SparcRTL.TICCBCS {r=TMP2, i=TMP0})
         val TICCBNEG = RTL.new (SparcRTL.TICCBNEG {r=TMP2, i=TMP0})
         val TICCBVS = RTL.new (SparcRTL.TICCBVS {r=TMP2, i=TMP0})
         val TICCBA = RTL.new (SparcRTL.TICCBA {r=TMP2, i=TMP0})
         val TICCBNE = RTL.new (SparcRTL.TICCBNE {r=TMP2, i=TMP0})
         val TICCBG = RTL.new (SparcRTL.TICCBG {r=TMP2, i=TMP0})
         val TICCBGE = RTL.new (SparcRTL.TICCBGE {r=TMP2, i=TMP0})
         val TICCBGU = RTL.new (SparcRTL.TICCBGU {r=TMP2, i=TMP0})
         val TICCBCC = RTL.new (SparcRTL.TICCBCC {r=TMP2, i=TMP0})
         val TICCBPOS = RTL.new (SparcRTL.TICCBPOS {r=TMP2, i=TMP0})
         val TICCBVC = RTL.new (SparcRTL.TICCBVC {r=TMP2, i=TMP0})
         val TXCCBN = RTL.new (SparcRTL.TXCCBN {r=TMP2, i=TMP0})
         val TXCCBE = RTL.new (SparcRTL.TXCCBE {r=TMP2, i=TMP0})
         val TXCCBLE = RTL.new (SparcRTL.TXCCBLE {r=TMP2, i=TMP0})
         val TXCCBL = RTL.new (SparcRTL.TXCCBL {r=TMP2, i=TMP0})
         val TXCCBLEU = RTL.new (SparcRTL.TXCCBLEU {r=TMP2, i=TMP0})
         val TXCCBCS = RTL.new (SparcRTL.TXCCBCS {r=TMP2, i=TMP0})
         val TXCCBNEG = RTL.new (SparcRTL.TXCCBNEG {r=TMP2, i=TMP0})
         val TXCCBVS = RTL.new (SparcRTL.TXCCBVS {r=TMP2, i=TMP0})
         val TXCCBA = RTL.new (SparcRTL.TXCCBA {r=TMP2, i=TMP0})
         val TXCCBNE = RTL.new (SparcRTL.TXCCBNE {r=TMP2, i=TMP0})
         val TXCCBG = RTL.new (SparcRTL.TXCCBG {r=TMP2, i=TMP0})
         val TXCCBGE = RTL.new (SparcRTL.TXCCBGE {r=TMP2, i=TMP0})
         val TXCCBGU = RTL.new (SparcRTL.TXCCBGU {r=TMP2, i=TMP0})
         val TXCCBCC = RTL.new (SparcRTL.TXCCBCC {r=TMP2, i=TMP0})
         val TXCCBPOS = RTL.new (SparcRTL.TXCCBPOS {r=TMP2, i=TMP0})
         val TXCCBVC = RTL.new (SparcRTL.TXCCBVC {r=TMP2, i=TMP0})
         val JMP = RTL.new (SparcRTL.JMP {r=TMP2, i=TMP0})
         val JMPL = RTL.new (SparcRTL.JMPL {r=TMP2, i=TMP0, d=TMP0, defs=TMP9, uses=TMP3, mem=TMP10})
         val CALL = RTL.new (SparcRTL.CALL {label=TMP5, defs=TMP5, uses=TMP5, mem=TMP11})
         val RET = RTL.new (SparcRTL.RET {})
      end
   end

   fun rtl instr = let
          fun undefined () = bug ("rtl", instr)
          fun query (I.LOAD{l, d, r, i, mem}) = 
              (
               case l of
               I.LDSB => Arch.LDSB
             | I.LDSH => Arch.LDSH
             | I.LDUB => Arch.LDUB
             | I.LDUH => Arch.LDUH
             | I.LD => Arch.LD
             | I.LDX => Arch.LDX
             | I.LDD => undefined ()
              )
            | query (I.STORE{s, d, r, i, mem}) = 
              (
               case s of
               I.STB => Arch.STB
             | I.STH => Arch.STH
             | I.ST => Arch.ST
             | I.STX => Arch.STX
             | I.STD => undefined ()
              )
            | query (I.FLOAD{l, r, i, d, mem}) = 
              (
               case l of
               I.LDF => Arch.LDF
             | I.LDDF => Arch.LDDF
             | I.LDQF => Arch.LDQF
             | I.LDFSR => Arch.LDFSR
             | I.LDXFSR => Arch.LDXFSR
              )
            | query (I.FSTORE{s, d, r, i, mem}) = 
              (
               case s of
               I.STF => Arch.STF
             | I.STDF => Arch.STDF
             | I.STFSR => Arch.STFSR
              )
            | query (I.SETHI{i, d}) = Arch.SETHI
            | query (I.ARITH{a, r, i, d}) = 
              (
               case (a, r) of
               (I.OR, 0) => Arch.li
             | _ => 
               (
                case a of
                I.AND => Arch.AND
              | I.ANDCC => Arch.ANDCC
              | I.ANDN => Arch.ANDN
              | I.ANDNCC => Arch.ANDNCC
              | I.OR => Arch.OR
              | I.ORCC => Arch.ORCC
              | I.ORN => Arch.ORN
              | I.ORNCC => Arch.ORNCC
              | I.XOR => Arch.XOR
              | I.XORCC => Arch.XORCC
              | I.XNOR => Arch.XNOR
              | I.XNORCC => Arch.XNORCC
              | I.ADD => Arch.ADD
              | I.ADDCC => Arch.ADDCC
              | I.TADD => Arch.TADD
              | I.TADDCC => Arch.TADDCC
              | I.TADDTV => Arch.TADDTV
              | I.TADDTVCC => Arch.TADDTVCC
              | I.SUB => Arch.SUB
              | I.SUBCC => Arch.SUBCC
              | I.TSUB => Arch.TSUB
              | I.TSUBCC => Arch.TSUBCC
              | I.TSUBTV => Arch.TSUBTV
              | I.TSUBTVCC => Arch.TSUBTVCC
              | I.UMUL => Arch.UMUL
              | I.UMULCC => Arch.UMULCC
              | I.SMUL => Arch.SMUL
              | I.SMULCC => Arch.SMULCC
              | I.UDIV => Arch.UDIV
              | I.UDIVCC => Arch.UDIVCC
              | I.SDIV => Arch.SDIV
              | I.SDIVCC => Arch.SDIVCC
              | I.MULX => Arch.MULX
              | I.SDIVX => Arch.SDIVX
              | I.UDIVX => Arch.UDIVX
               )
              )
            | query (I.SHIFT{s, r, i, d}) = 
              (
               case s of
               I.SLL => Arch.SLL
             | I.SRL => Arch.SRL
             | I.SRA => Arch.SRA
             | I.SLLX => Arch.SLLX
             | I.SRLX => Arch.SRLX
             | I.SRAX => Arch.SRAX
              )
            | query (I.Bicc{b, a, label, nop}) = 
              (
               case b of
               I.BN => Arch.BN
             | I.BE => Arch.BE
             | I.BLE => Arch.BLE
             | I.BL => Arch.BL
             | I.BLEU => Arch.BLEU
             | I.BCS => Arch.BCS
             | I.BNEG => Arch.BNEG
             | I.BVS => Arch.BVS
             | I.BA => Arch.BA
             | I.BNE => Arch.BNE
             | I.BG => Arch.BG
             | I.BGE => Arch.BGE
             | I.BGU => Arch.BGU
             | I.BCC => Arch.BCC
             | I.BPOS => Arch.BPOS
             | I.BVC => Arch.BVC
              )
            | query (I.FBfcc{b, a, label, nop}) = 
              (
               case b of
               I.FBN => Arch.FBN
             | I.FBNE => Arch.FBNE
             | I.FBLG => Arch.FBLG
             | I.FBUL => Arch.FBUL
             | I.FBL => Arch.FBL
             | I.FBUG => Arch.FBUG
             | I.FBG => Arch.FBG
             | I.FBU => Arch.FBU
             | I.FBA => Arch.FBA
             | I.FBE => Arch.FBE
             | I.FBUE => Arch.FBUE
             | I.FBGE => Arch.FBGE
             | I.FBUGE => Arch.FBUGE
             | I.FBLE => Arch.FBLE
             | I.FBULE => Arch.FBULE
             | I.FBO => Arch.FBO
              )
            | query (I.JMP{r, i, labs, nop}) = Arch.JMP
            | query (I.JMPL{r, i, d, defs, uses, nop, mem}) = Arch.JMPL
            | query (I.CALL{defs, uses, label, nop, mem}) = Arch.CALL
            | query (I.Ticc{t, cc, r, i}) = 
              (
               case (cc, t) of
               (I.ICC, I.BN) => Arch.TICCBN
             | (I.XCC, I.BN) => Arch.TXCCBN
             | (I.ICC, I.BE) => Arch.TICCBE
             | (I.XCC, I.BE) => Arch.TXCCBE
             | (I.ICC, I.BLE) => Arch.TICCBLE
             | (I.XCC, I.BLE) => Arch.TXCCBLE
             | (I.ICC, I.BL) => Arch.TICCBL
             | (I.XCC, I.BL) => Arch.TXCCBL
             | (I.ICC, I.BLEU) => Arch.TICCBLEU
             | (I.XCC, I.BLEU) => Arch.TXCCBLEU
             | (I.ICC, I.BCS) => Arch.TICCBCS
             | (I.XCC, I.BCS) => Arch.TXCCBCS
             | (I.ICC, I.BNEG) => Arch.TICCBNEG
             | (I.XCC, I.BNEG) => Arch.TXCCBNEG
             | (I.ICC, I.BVS) => Arch.TICCBVS
             | (I.XCC, I.BVS) => Arch.TXCCBVS
             | (I.ICC, I.BA) => Arch.TICCBA
             | (I.XCC, I.BA) => Arch.TXCCBA
             | (I.ICC, I.BNE) => Arch.TICCBNE
             | (I.XCC, I.BNE) => Arch.TXCCBNE
             | (I.ICC, I.BG) => Arch.TICCBG
             | (I.XCC, I.BG) => Arch.TXCCBG
             | (I.ICC, I.BGE) => Arch.TICCBGE
             | (I.XCC, I.BGE) => Arch.TXCCBGE
             | (I.ICC, I.BGU) => Arch.TICCBGU
             | (I.XCC, I.BGU) => Arch.TXCCBGU
             | (I.ICC, I.BCC) => Arch.TICCBCC
             | (I.XCC, I.BCC) => Arch.TXCCBCC
             | (I.ICC, I.BPOS) => Arch.TICCBPOS
             | (I.XCC, I.BPOS) => Arch.TXCCBPOS
             | (I.ICC, I.BVC) => Arch.TICCBVC
             | (I.XCC, I.BVC) => Arch.TXCCBVC
              )
            | query (I.FPop1{a, r, d}) = 
              (
               case a of
               I.FiTOs => Arch.FiTOs
             | I.FiTOd => Arch.FiTOd
             | I.FiTOq => Arch.FiTOq
             | I.FsTOi => Arch.FsTOi
             | I.FdTOi => Arch.FdTOi
             | I.FqTOi => Arch.FqTOi
             | I.FsTOd => Arch.FsTOd
             | I.FsTOq => Arch.FsTOq
             | I.FdTOs => Arch.FdTOs
             | I.FdTOq => Arch.FdTOq
             | I.FqTOs => Arch.FqTOs
             | I.FqTOd => Arch.FqTOd
             | I.FMOVs => Arch.FMOVs
             | I.FNEGs => Arch.FNEGs
             | I.FABSs => Arch.FABSs
             | I.FMOVd => Arch.FMOVd
             | I.FNEGd => Arch.FNEGd
             | I.FABSd => Arch.FABSd
             | I.FMOVq => Arch.FMOVq
             | I.FNEGq => Arch.FNEGq
             | I.FABSq => Arch.FABSq
             | I.FSQRTs => Arch.FSQRTs
             | I.FSQRTd => Arch.FSQRTd
             | I.FSQRTq => Arch.FSQRTq
              )
            | query (I.FPop2{a, r1, r2, d}) = 
              (
               case a of
               I.FADDs => Arch.FADDs
             | I.FADDd => Arch.FADDd
             | I.FADDq => Arch.FADDq
             | I.FSUBs => Arch.FSUBs
             | I.FSUBd => Arch.FSUBd
             | I.FSUBq => Arch.FSUBq
             | I.FMULs => Arch.FMULs
             | I.FMULd => Arch.FMULd
             | I.FMULq => Arch.FMULq
             | I.FsMULd => Arch.FsMULd
             | I.FdMULq => Arch.FdMULq
             | I.FDIVs => Arch.FDIVs
             | I.FDIVd => Arch.FDIVd
             | I.FDIVq => Arch.FDIVq
              )
            | query (I.FCMP{cmp, r1, r2, nop}) = 
              (
               case cmp of
               I.FCMPs => Arch.FCMPs
             | I.FCMPd => Arch.FCMPd
             | I.FCMPq => Arch.FCMPq
             | I.FCMPEs => Arch.FCMPEs
             | I.FCMPEd => Arch.FCMPEd
             | I.FCMPEq => Arch.FCMPEq
              )
            | query (I.COPY{dst, src, impl, tmp}) = Arch.COPY
            | query (I.FCOPY{dst, src, impl, tmp}) = Arch.FCOPY
            | query (I.RDY{d}) = Arch.RDY
            | query (I.WRY{r, i}) = Arch.WRY
            | query (I.RET{leaf, nop}) = Arch.RET
            | query (I.ANNOTATION{i, a}) = query i
            | query _ = undefined ()
       in query instr
       end

   fun defUse {immed, operand} instr = let
          fun undefined () = bug ("defUse", instr)
          fun getOpnd' opnd = 
              (
               case opnd of
               I.REG GP => GP
             | I.IMMED int => immed int
             | _ => operand opnd
              )
          fun getOpnd x = getOpnd' x
          fun getImm i  = immed i
          fun getRegionUse r = RegionProps.readFrom r
          fun getRegionDef r =
          let val (d,u) = RegionProps.writeTo r
          in  d end
          fun withKind(k,l) = l
          fun getCellSet (GP, FP, PSR) = (withKind (C.GP, GP)) @ ((withKind (C.FP, FP)) @ (withKind (C.PSR, PSR)))
          fun query (I.LOAD{l, d, r, i, mem}) = 
              (
               case l of
               (I.LDSB | I.LDSH | I.LDUB | I.LDUH | I.LD | I.LDX) => ([d], (getOpnd i)::r::(getRegionUse mem))
             | I.LDD => undefined ()
              )
            | query (I.STORE{s, d, r, i, mem}) = 
              (
               case s of
               (I.STB | I.STH | I.ST | I.STX) => (getRegionDef mem, [getOpnd i, d, r])
             | I.STD => undefined ()
              )
            | query (I.FLOAD{l, r, i, d, mem}) = 
              (
               case l of
               (I.LDF | I.LDDF | I.LDQF) => ([d], (getOpnd i)::r::(getRegionUse mem))
             | (I.LDFSR | I.LDXFSR) => ([66], (getOpnd i)::r::(getRegionUse mem))
              )
            | query (I.FSTORE{s, d, r, i, mem}) = 
              (
               case s of
               (I.STF | I.STDF) => (getRegionDef mem, [getOpnd i, d, r])
             | I.STFSR => (getRegionDef mem, [getOpnd i, r, 66])
              )
            | query (I.SETHI{i, d}) = ([d], [getImm i])
            | query (I.ARITH{a, r, i, d}) = 
              (
               case (a, r) of
               (I.OR, 0) => ([d], [getOpnd i])
             | _ => 
               (
                case a of
                (I.UMUL | I.UMULCC | I.SMUL | I.SMULCC) => ([d, 64], [getOpnd i, r])
              | 
                ( I.ANDCC |
                I.ANDNCC |
                I.ORCC |
                I.ORNCC |
                I.XORCC |
                I.XNORCC |
                I.ADDCC |
                I.TADDCC |
                I.TADDTVCC |
                I.SUBCC |
                I.TSUBCC |
                I.TSUBTVCC |
                I.UDIVCC |
                I.SDIVCC ) => ([d, 65], [getOpnd i, r])
              | 
                ( I.AND |
                I.ANDN |
                I.OR |
                I.ORN |
                I.XOR |
                I.XNOR |
                I.ADD |
                I.TADD |
                I.TADDTV |
                I.SUB |
                I.TSUB |
                I.TSUBTV |
                I.UDIV |
                I.SDIV |
                I.MULX |
                I.SDIVX |
                I.UDIVX ) => ([d], [getOpnd i, r])
               )
              )
            | query (I.SHIFT{s, r, i, d}) = ([d], [getOpnd i, r])
            | query (I.Bicc{b, a, label, nop}) = 
              (
               case b of
               (I.BN | I.BA) => ([], [])
             | 
               ( I.BE |
               I.BLE |
               I.BL |
               I.BLEU |
               I.BCS |
               I.BNEG |
               I.BVS |
               I.BNE |
               I.BG |
               I.BGE |
               I.BGU |
               I.BCC |
               I.BPOS |
               I.BVC ) => ([], [65])
              )
            | query (I.FBfcc{b, a, label, nop}) = ([], [66])
            | query (I.JMP{r, i, labs, nop}) = ([], [getOpnd i, r])
            | query (I.JMPL{r, i, d, defs, uses, nop, mem}) = (d::((getCellSet defs) @ (getRegionDef mem)), (getOpnd i)::r::((getCellSet uses) @ (getRegionUse mem)))
            | query (I.CALL{defs, uses, label, nop, mem}) = ((getCellSet defs) @ (getRegionDef mem), (getCellSet uses) @ (getRegionUse mem))
            | query (I.Ticc{t, cc, r, i}) = 
              (
               case (cc, t) of
               ((I.ICC, I.BN)|(I.XCC, I.BN)|(I.ICC, I.BA)|(I.XCC, I.BA)) => ([], [getOpnd i, r])
             | 
               ((I.ICC, I.BE)|
               (I.XCC, I.BE)|
               (I.ICC, I.BLE)|
               (I.XCC, I.BLE)|
               (I.ICC, I.BL)|
               (I.XCC, I.BL)|
               (I.ICC, I.BLEU)|
               (I.XCC, I.BLEU)|
               (I.ICC, I.BCS)|
               (I.XCC, I.BCS)|
               (I.ICC, I.BNEG)|
               (I.XCC, I.BNEG)|
               (I.ICC, I.BVS)|
               (I.XCC, I.BVS)|
               (I.ICC, I.BNE)|
               (I.XCC, I.BNE)|
               (I.ICC, I.BG)|
               (I.XCC, I.BG)|
               (I.ICC, I.BGE)|
               (I.XCC, I.BGE)|
               (I.ICC, I.BGU)|
               (I.XCC, I.BGU)|
               (I.ICC, I.BCC)|
               (I.XCC, I.BCC)|
               (I.ICC, I.BPOS)|
               (I.XCC, I.BPOS)|
               (I.ICC, I.BVC)|
               (I.XCC, I.BVC)) => ([], [getOpnd i, r, 65])
              )
            | query (I.FPop1{a, r, d}) = ([d], [r])
            | query (I.FPop2{a, r1, r2, d}) = ([d], [r1, r2])
            | query (I.FCMP{cmp, r1, r2, nop}) = ([66], [r1, r2])
            | query (I.COPY{dst, src, impl, tmp}) = (withKind (C.GP, dst), withKind (C.GP, src))
            | query (I.FCOPY{dst, src, impl, tmp}) = (withKind (C.FP, dst), withKind (C.FP, src))
            | query (I.RDY{d}) = ([d], [64])
            | query (I.WRY{r, i}) = ([64], [getOpnd i, r])
            | query (I.RET{leaf, nop}) = ([], [])
            | query (I.ANNOTATION{i, a}) = query i
            | query _ = undefined ()
       in query instr
       end

   fun defUseWithCellKind {immed, operand} instr = let
          fun undefined () = bug ("defUseWithCellKind", instr)
          fun getOpnd' opnd = 
              (
               case opnd of
               I.REG GP => GP
             | I.IMMED int => immed int
             | _ => operand opnd
              )
          fun getOpnd x = (getOpnd' x,C.GP)
          fun getImm x  = (immed x,C.GP)
          fun getRegionUse r = 
            map (fn r => (r,C.MEM)) (RegionProps.readFrom r)
          fun getRegionDef r = 
            let val (d,u) = RegionProps.writeTo r
            in  map (fn r => (r,C.MEM)) d end
          fun withKind(k,l) = map (fn x => (x,k)) l
          fun getCellSet (GP, FP, PSR) = (withKind (C.GP, GP)) @ ((withKind (C.FP, FP)) @ (withKind (C.PSR, PSR)))
          fun query (I.LOAD{l, d, r, i, mem}) = 
              (
               case l of
               (I.LDSB | I.LDSH | I.LDUB | I.LDUH | I.LD | I.LDX) => ([(d, C.GP)], (getOpnd i)::(r, C.GP)::(getRegionUse mem))
             | I.LDD => undefined ()
              )
            | query (I.STORE{s, d, r, i, mem}) = 
              (
               case s of
               (I.STB | I.STH | I.ST | I.STX) => (getRegionDef mem, [getOpnd i, (d, C.GP), (r, C.GP)])
             | I.STD => undefined ()
              )
            | query (I.FLOAD{l, r, i, d, mem}) = 
              (
               case l of
               (I.LDF | I.LDDF | I.LDQF) => ([(d, C.FP)], (getOpnd i)::(r, C.GP)::(getRegionUse mem))
             | (I.LDFSR | I.LDXFSR) => ([(66, C.FSR)], (getOpnd i)::(r, C.GP)::(getRegionUse mem))
              )
            | query (I.FSTORE{s, d, r, i, mem}) = 
              (
               case s of
               (I.STF | I.STDF) => (getRegionDef mem, [getOpnd i, (d, C.FP), (r, C.GP)])
             | I.STFSR => (getRegionDef mem, [getOpnd i, (r, C.GP), (66, C.FSR)])
              )
            | query (I.SETHI{i, d}) = ([(d, C.GP)], [getImm i])
            | query (I.ARITH{a, r, i, d}) = 
              (
               case (a, r) of
               (I.OR, 0) => ([(d, C.GP)], [getOpnd i])
             | _ => 
               (
                case a of
                (I.UMUL | I.UMULCC | I.SMUL | I.SMULCC) => ([(d, C.GP), (64, C.Y)], [getOpnd i, (r, C.GP)])
              | 
                ( I.ANDCC |
                I.ANDNCC |
                I.ORCC |
                I.ORNCC |
                I.XORCC |
                I.XNORCC |
                I.ADDCC |
                I.TADDCC |
                I.TADDTVCC |
                I.SUBCC |
                I.TSUBCC |
                I.TSUBTVCC |
                I.UDIVCC |
                I.SDIVCC ) => ([(d, C.GP), (65, C.PSR)], [getOpnd i, (r, C.GP)])
              | 
                ( I.AND |
                I.ANDN |
                I.OR |
                I.ORN |
                I.XOR |
                I.XNOR |
                I.ADD |
                I.TADD |
                I.TADDTV |
                I.SUB |
                I.TSUB |
                I.TSUBTV |
                I.UDIV |
                I.SDIV |
                I.MULX |
                I.SDIVX |
                I.UDIVX ) => ([(d, C.GP)], [getOpnd i, (r, C.GP)])
               )
              )
            | query (I.SHIFT{s, r, i, d}) = ([(d, C.GP)], [getOpnd i, (r, C.GP)])
            | query (I.Bicc{b, a, label, nop}) = 
              (
               case b of
               (I.BN | I.BA) => ([], [])
             | 
               ( I.BE |
               I.BLE |
               I.BL |
               I.BLEU |
               I.BCS |
               I.BNEG |
               I.BVS |
               I.BNE |
               I.BG |
               I.BGE |
               I.BGU |
               I.BCC |
               I.BPOS |
               I.BVC ) => ([], [(65, C.PSR)])
              )
            | query (I.FBfcc{b, a, label, nop}) = ([], [(66, C.FSR)])
            | query (I.JMP{r, i, labs, nop}) = ([], [getOpnd i, (r, C.GP)])
            | query (I.JMPL{r, i, d, defs, uses, nop, mem}) = ((d, C.GP)::((getCellSet defs) @ (getRegionDef mem)), (getOpnd i)::(r, C.GP)::((getCellSet uses) @ (getRegionUse mem)))
            | query (I.CALL{defs, uses, label, nop, mem}) = ((getCellSet defs) @ (getRegionDef mem), (getCellSet uses) @ (getRegionUse mem))
            | query (I.Ticc{t, cc, r, i}) = 
              (
               case (cc, t) of
               ((I.ICC, I.BN)|(I.XCC, I.BN)|(I.ICC, I.BA)|(I.XCC, I.BA)) => ([], [getOpnd i, (r, C.GP)])
             | 
               ((I.ICC, I.BE)|
               (I.XCC, I.BE)|
               (I.ICC, I.BLE)|
               (I.XCC, I.BLE)|
               (I.ICC, I.BL)|
               (I.XCC, I.BL)|
               (I.ICC, I.BLEU)|
               (I.XCC, I.BLEU)|
               (I.ICC, I.BCS)|
               (I.XCC, I.BCS)|
               (I.ICC, I.BNEG)|
               (I.XCC, I.BNEG)|
               (I.ICC, I.BVS)|
               (I.XCC, I.BVS)|
               (I.ICC, I.BNE)|
               (I.XCC, I.BNE)|
               (I.ICC, I.BG)|
               (I.XCC, I.BG)|
               (I.ICC, I.BGE)|
               (I.XCC, I.BGE)|
               (I.ICC, I.BGU)|
               (I.XCC, I.BGU)|
               (I.ICC, I.BCC)|
               (I.XCC, I.BCC)|
               (I.ICC, I.BPOS)|
               (I.XCC, I.BPOS)|
               (I.ICC, I.BVC)|
               (I.XCC, I.BVC)) => ([], [getOpnd i, (r, C.GP), (65, C.PSR)])
              )
            | query (I.FPop1{a, r, d}) = ([(d, C.FP)], [(r, C.FP)])
            | query (I.FPop2{a, r1, r2, d}) = ([(d, C.FP)], [(r1, C.FP), (r2, C.FP)])
            | query (I.FCMP{cmp, r1, r2, nop}) = ([(66, C.FSR)], [(r1, C.FP), (r2, C.FP)])
            | query (I.COPY{dst, src, impl, tmp}) = (withKind (C.GP, dst), withKind (C.GP, src))
            | query (I.FCOPY{dst, src, impl, tmp}) = (withKind (C.FP, dst), withKind (C.FP, src))
            | query (I.RDY{d}) = ([(d, C.GP)], [(64, C.Y)])
            | query (I.WRY{r, i}) = ([(64, C.Y)], [getOpnd i, (r, C.GP)])
            | query (I.RET{leaf, nop}) = ([], [])
            | query (I.ANNOTATION{i, a}) = query i
            | query _ = undefined ()
       in query instr
       end

   local
      val TMP0 = [REG]
      val TMP1 = [IMM, REG, REG]
      val TMP2 = [FIX]
      val TMP3 = [IMM, REG, FIX]
      val TMP4 = [IMM]
      val TMP5 = [IMM, REG]
      val TMP6 = [REG, FIX]
      val TMP7 = []
      val TMP8 = [REG, REG]
   in
      fun opnKind instr = let
             fun undefined () = bug ("opnKind", instr)
             fun REGs rs = map (fn _ => REG) rs
             fun FIXs rs = map (fn _ => FIX) rs
             fun MEMs rs = map (fn _ => MEM) rs
             fun getCellSet (GP, FP, PSR) = (FIXs GP) @ ((FIXs FP) @ (FIXs PSR))
             fun getRegionUse r = MEMs (RegionProps.readFrom r)
             fun getRegionDef r = 
             let val (d,u) = RegionProps.writeTo r
             in  MEMs d end
             fun query (I.LOAD{l, d, r, i, mem}) = 
                 (
                  case l of
                  (I.LDSB | I.LDSH | I.LDUB | I.LDUH | I.LD | I.LDX) => (TMP0, IMM::REG::(getRegionUse mem))
                | I.LDD => undefined ()
                 )
               | query (I.STORE{s, d, r, i, mem}) = 
                 (
                  case s of
                  (I.STB | I.STH | I.ST | I.STX) => (getRegionDef mem, TMP1)
                | I.STD => undefined ()
                 )
               | query (I.FLOAD{l, r, i, d, mem}) = 
                 (
                  case l of
                  (I.LDF | I.LDDF | I.LDQF) => (TMP0, IMM::REG::(getRegionUse mem))
                | (I.LDFSR | I.LDXFSR) => (TMP2, IMM::REG::(getRegionUse mem))
                 )
               | query (I.FSTORE{s, d, r, i, mem}) = 
                 (
                  case s of
                  (I.STF | I.STDF) => (getRegionDef mem, TMP1)
                | I.STFSR => (getRegionDef mem, TMP3)
                 )
               | query (I.SETHI{i, d}) = (TMP0, TMP4)
               | query (I.ARITH{a, r, i, d}) = 
                 (
                  case (a, r) of
                  (I.OR, 0) => (TMP0, TMP4)
                | _ => 
                  (
                   case a of
                   
                   ( I.ANDCC |
                   I.ANDNCC |
                   I.ORCC |
                   I.ORNCC |
                   I.XORCC |
                   I.XNORCC |
                   I.ADDCC |
                   I.TADDCC |
                   I.TADDTVCC |
                   I.SUBCC |
                   I.TSUBCC |
                   I.TSUBTVCC |
                   I.UMUL |
                   I.UMULCC |
                   I.SMUL |
                   I.SMULCC |
                   I.UDIVCC |
                   I.SDIVCC ) => (TMP6, TMP5)
                 | 
                   ( I.AND |
                   I.ANDN |
                   I.OR |
                   I.ORN |
                   I.XOR |
                   I.XNOR |
                   I.ADD |
                   I.TADD |
                   I.TADDTV |
                   I.SUB |
                   I.TSUB |
                   I.TSUBTV |
                   I.UDIV |
                   I.SDIV |
                   I.MULX |
                   I.SDIVX |
                   I.UDIVX ) => (TMP0, TMP5)
                  )
                 )
               | query (I.SHIFT{s, r, i, d}) = (TMP0, TMP5)
               | query (I.Bicc{b, a, label, nop}) = 
                 (
                  case b of
                  (I.BN | I.BA) => (TMP7, TMP7)
                | 
                  ( I.BE |
                  I.BLE |
                  I.BL |
                  I.BLEU |
                  I.BCS |
                  I.BNEG |
                  I.BVS |
                  I.BNE |
                  I.BG |
                  I.BGE |
                  I.BGU |
                  I.BCC |
                  I.BPOS |
                  I.BVC ) => (TMP7, TMP2)
                 )
               | query (I.FBfcc{b, a, label, nop}) = (TMP7, TMP2)
               | query (I.JMP{r, i, labs, nop}) = (TMP7, TMP5)
               | query (I.JMPL{r, i, d, defs, uses, nop, mem}) = (REG::((getCellSet defs) @ (getRegionDef mem)), IMM::REG::((getCellSet uses) @ (getRegionUse mem)))
               | query (I.CALL{defs, uses, label, nop, mem}) = ((getCellSet defs) @ (getRegionDef mem), (getCellSet uses) @ (getRegionUse mem))
               | query (I.Ticc{t, cc, r, i}) = 
                 (
                  case (cc, t) of
                  ((I.ICC, I.BN)|(I.XCC, I.BN)|(I.ICC, I.BA)|(I.XCC, I.BA)) => (TMP7, TMP5)
                | 
                  ((I.ICC, I.BE)|
                  (I.XCC, I.BE)|
                  (I.ICC, I.BLE)|
                  (I.XCC, I.BLE)|
                  (I.ICC, I.BL)|
                  (I.XCC, I.BL)|
                  (I.ICC, I.BLEU)|
                  (I.XCC, I.BLEU)|
                  (I.ICC, I.BCS)|
                  (I.XCC, I.BCS)|
                  (I.ICC, I.BNEG)|
                  (I.XCC, I.BNEG)|
                  (I.ICC, I.BVS)|
                  (I.XCC, I.BVS)|
                  (I.ICC, I.BNE)|
                  (I.XCC, I.BNE)|
                  (I.ICC, I.BG)|
                  (I.XCC, I.BG)|
                  (I.ICC, I.BGE)|
                  (I.XCC, I.BGE)|
                  (I.ICC, I.BGU)|
                  (I.XCC, I.BGU)|
                  (I.ICC, I.BCC)|
                  (I.XCC, I.BCC)|
                  (I.ICC, I.BPOS)|
                  (I.XCC, I.BPOS)|
                  (I.ICC, I.BVC)|
                  (I.XCC, I.BVC)) => (TMP7, TMP3)
                 )
               | query (I.FPop1{a, r, d}) = (TMP0, TMP0)
               | query (I.FPop2{a, r1, r2, d}) = (TMP0, TMP8)
               | query (I.FCMP{cmp, r1, r2, nop}) = (TMP2, TMP8)
               | query (I.COPY{dst, src, impl, tmp}) = (REGs dst, REGs src)
               | query (I.FCOPY{dst, src, impl, tmp}) = (REGs dst, REGs src)
               | query (I.RDY{d}) = (TMP0, TMP2)
               | query (I.WRY{r, i}) = (TMP2, TMP5)
               | query (I.RET{leaf, nop}) = (TMP7, TMP7)
               | query (I.ANNOTATION{i, a}) = query i
               | query _ = undefined ()
          in query instr
          end

   end
   fun updateCellKind {update} instr = let
          fun undefined () = bug ("updateCellKind", instr)
          fun enterGP r = update (r, C.GP)
          and enterFP r = update (r, C.FP)
          and enterY r = update (r, C.Y)
          and enterPSR r = update (r, C.PSR)
          and enterFSR r = update (r, C.FSR)
          and enterCC r = update (r, C.CC)
          and enterMEM r = update (r, C.MEM)
          and enterCTRL r = update (r, C.CTRL)
          fun enterCellSet (GP, FP, PSR) = 
              ( app enterFP FP; 
              app enterPSR PSR )
          fun enterRegionUse r = app enterMEM (RegionProps.readFrom r)
          fun enterRegionDef r = 
          let val (d,u) = RegionProps.writeTo r
          in  app enterMEM d; app enterMEM u end
          fun query (I.LOAD{l, d, r, i, mem}) = 
              (
               case l of
               (I.LDSB | I.LDSH | I.LDUB | I.LDUH | I.LD | I.LDX) => enterRegionUse mem
             | I.LDD => undefined ()
              )
            | query (I.STORE{s, d, r, i, mem}) = 
              (
               case s of
               (I.STB | I.STH | I.ST | I.STX) => enterRegionDef mem
             | I.STD => undefined ()
              )
            | query (I.FLOAD{l, r, i, d, mem}) = 
              (
               case l of
               (I.LDF | I.LDDF | I.LDQF) => 
               ( enterFP d; 
               enterRegionUse mem )
             | (I.LDFSR | I.LDXFSR) => 
               ( enterFSR 66; 
               enterRegionUse mem )
              )
            | query (I.FSTORE{s, d, r, i, mem}) = 
              (
               case s of
               (I.STF | I.STDF) => 
               ( enterRegionDef mem; 
               enterFP d )
             | I.STFSR => 
               ( enterRegionDef mem; 
               enterFSR 66 )
              )
            | query (I.SETHI{i, d}) = ()
            | query (I.ARITH{a, r, i, d}) = 
              (
               case (a, r) of
               (I.OR, 0) => ()
             | _ => 
               (
                case a of
                (I.UMUL | I.UMULCC | I.SMUL | I.SMULCC) => enterY 64
              | 
                ( I.ANDCC |
                I.ANDNCC |
                I.ORCC |
                I.ORNCC |
                I.XORCC |
                I.XNORCC |
                I.ADDCC |
                I.TADDCC |
                I.TADDTVCC |
                I.SUBCC |
                I.TSUBCC |
                I.TSUBTVCC |
                I.UDIVCC |
                I.SDIVCC ) => enterPSR 65
              | 
                ( I.AND |
                I.ANDN |
                I.OR |
                I.ORN |
                I.XOR |
                I.XNOR |
                I.ADD |
                I.TADD |
                I.TADDTV |
                I.SUB |
                I.TSUB |
                I.TSUBTV |
                I.UDIV |
                I.SDIV |
                I.MULX |
                I.SDIVX |
                I.UDIVX ) => ()
               )
              )
            | query (I.SHIFT{s, r, i, d}) = ()
            | query (I.Bicc{b, a, label, nop}) = 
              (
               case b of
               (I.BN | I.BA) => ()
             | 
               ( I.BE |
               I.BLE |
               I.BL |
               I.BLEU |
               I.BCS |
               I.BNEG |
               I.BVS |
               I.BNE |
               I.BG |
               I.BGE |
               I.BGU |
               I.BCC |
               I.BPOS |
               I.BVC ) => enterPSR 65
              )
            | query (I.FBfcc{b, a, label, nop}) = enterFSR 66
            | query (I.JMP{r, i, labs, nop}) = ()
            | query (I.JMPL{r, i, d, defs, uses, nop, mem}) = 
              ( enterCellSet defs; 
              enterRegionDef mem; 
              enterCellSet uses; 
              enterRegionUse mem )
            | query (I.CALL{defs, uses, label, nop, mem}) = 
              ( enterCellSet defs; 
              enterRegionDef mem; 
              enterCellSet uses; 
              enterRegionUse mem )
            | query (I.Ticc{t, cc, r, i}) = 
              (
               case (cc, t) of
               ((I.ICC, I.BN)|(I.XCC, I.BN)|(I.ICC, I.BA)|(I.XCC, I.BA)) => ()
             | 
               ((I.ICC, I.BE)|
               (I.XCC, I.BE)|
               (I.ICC, I.BLE)|
               (I.XCC, I.BLE)|
               (I.ICC, I.BL)|
               (I.XCC, I.BL)|
               (I.ICC, I.BLEU)|
               (I.XCC, I.BLEU)|
               (I.ICC, I.BCS)|
               (I.XCC, I.BCS)|
               (I.ICC, I.BNEG)|
               (I.XCC, I.BNEG)|
               (I.ICC, I.BVS)|
               (I.XCC, I.BVS)|
               (I.ICC, I.BNE)|
               (I.XCC, I.BNE)|
               (I.ICC, I.BG)|
               (I.XCC, I.BG)|
               (I.ICC, I.BGE)|
               (I.XCC, I.BGE)|
               (I.ICC, I.BGU)|
               (I.XCC, I.BGU)|
               (I.ICC, I.BCC)|
               (I.XCC, I.BCC)|
               (I.ICC, I.BPOS)|
               (I.XCC, I.BPOS)|
               (I.ICC, I.BVC)|
               (I.XCC, I.BVC)) => enterPSR 65
              )
            | query (I.FPop1{a, r, d}) = 
              ( enterFP d; 
              enterFP r )
            | query (I.FPop2{a, r1, r2, d}) = 
              ( enterFP d; 
              enterFP r1; 
              enterFP r2 )
            | query (I.FCMP{cmp, r1, r2, nop}) = 
              ( enterFSR 66; 
              enterFP r1; 
              enterFP r2 )
            | query (I.COPY{dst, src, impl, tmp}) = ()
            | query (I.FCOPY{dst, src, impl, tmp}) = 
              ( app enterFP dst; 
              app enterFP src )
            | query (I.RDY{d}) = enterY 64
            | query (I.WRY{r, i}) = enterY 64
            | query (I.RET{leaf, nop}) = ()
            | query (I.ANNOTATION{i, a}) = query i
            | query _ = undefined ()
       in query instr
       end

end

