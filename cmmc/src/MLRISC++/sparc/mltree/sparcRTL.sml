(*
 * This file was automatically generated by MDGen (v2.0)
 * from the machine description file "sparc/sparc.md".
 *)


functor SparcRTL(BuildRTL : BUILD_RTL
)= struct
   local
      open BuildRTL
   in

(*#line 4.1 "MD-2.0/basis.md"*)
      structure Basis = struct
      end


(*#line 57.7 "sparc/sparc.md"*)
      open Basis

(*#line 58.7 "sparc/sparc.md"*)
      infix 1 ||

(*#line 59.7 "sparc/sparc.md"*)
      infix 3 << >> ~>>

(*#line 61.7 "sparc/sparc.md"*)
      fun % x = operand 64 x

(*#line 62.7 "sparc/sparc.md"*)
      fun %% l = label 64 l

(*#line 65.7 "sparc/sparc.md"*)
      fun cc {} = op := 64 (idaggr 64 ( $ ("PSR", 64) (intConst 0 0)),  ? 64)

(*#line 67.7 "sparc/sparc.md"*)
      fun byte x = x

(*#line 68.7 "sparc/sparc.md"*)
      fun hword x = x

(*#line 69.7 "sparc/sparc.md"*)
      fun word x = x

(*#line 70.7 "sparc/sparc.md"*)
      fun dword x = x

(*#line 71.7 "sparc/sparc.md"*)
      fun single x = x

(*#line 72.7 "sparc/sparc.md"*)
      fun double x = x

(*#line 73.7 "sparc/sparc.md"*)
      fun quad x = x

(*#line 75.7 "sparc/sparc.md"*)
      fun disp (r, i) = op + 64 (fetch 64 (idaggr 64 ( $ ("GP", 64) r)),  % i)

(*#line 77.7 "sparc/sparc.md"*)
      val COPY = (fn {dst, src} => op := 64 (idaggr 64 ( $ ("GP", 64) (forall 5 dst)), fetch 64 (idaggr 64 ( $ ("GP", 64) (forall 5 src))))
                 )

(*#line 78.7 "sparc/sparc.md"*)
      val FCOPY = (fn {dst, src} => op := 32 (idaggr 32 ( $ ("FP", 32) (forall 5 dst)), fetch 32 (idaggr 32 ( $ ("FP", 32) (forall 5 src))))
                  )

(*#line 80.7 "sparc/sparc.md"*)
      val RDY = (fn {d} => op := 64 (idaggr 64 ( $ ("GP", 64) d), fetch 64 (idaggr 64 ( $ ("Y", 64) (intConst 0 0))))
                )

(*#line 81.7 "sparc/sparc.md"*)
      val WRY = (fn {r, i} => op := 64 (idaggr 64 ( $ ("Y", 64) (intConst 0 0)), disp (r, i))
                )

(*#line 83.7 "sparc/sparc.md"*)
      val SETHI = (fn {i, d} => op := 64 (idaggr 64 ( $ ("GP", 64) d), op << 64 (immed 64 i, intConst 64 10))
                  )

(*#line 86.7 "sparc/sparc.md"*)
      val LDSB = (fn {r, i, d, mem} => op := 64 (idaggr 64 ( $ ("GP", 64) d), sx (8, 64) (byte (fetch 8 (aggb (8, 8) ( $$ ("MEM", 8) (disp (r, i), mem))))))
                 )

(*#line 87.7 "sparc/sparc.md"*)
      val LDSH = (fn {r, i, d, mem} => op := 64 (idaggr 64 ( $ ("GP", 64) d), sx (16, 64) (hword (fetch 16 (aggb (8, 16) ( $$ ("MEM", 8) (disp (r, i), mem))))))
                 )

(*#line 88.7 "sparc/sparc.md"*)
      val LDUB = (fn {r, i, d, mem} => op := 64 (idaggr 64 ( $ ("GP", 64) d), zx (8, 64) (byte (fetch 8 (aggb (8, 8) ( $$ ("MEM", 8) (disp (r, i), mem))))))
                 )

(*#line 89.7 "sparc/sparc.md"*)
      val LDUH = (fn {r, i, d, mem} => op := 64 (idaggr 64 ( $ ("GP", 64) d), zx (16, 64) (hword (fetch 16 (aggb (8, 16) ( $$ ("MEM", 8) (disp (r, i), mem))))))
                 )

(*#line 90.7 "sparc/sparc.md"*)
      val LD = (fn {r, i, d, mem} => op := 64 (idaggr 64 ( $ ("GP", 64) d), zx (32, 64) (word (fetch 32 (aggb (8, 32) ( $$ ("MEM", 8) (disp (r, i), mem))))))
               )

(*#line 91.7 "sparc/sparc.md"*)
      val LDX = (fn {r, i, d, mem} => op := 64 (idaggr 64 ( $ ("GP", 64) d), zx (128, 64) (quad (fetch 128 (aggb (8, 128) ( $$ ("MEM", 8) (disp (r, i), mem))))))
                )

(*#line 92.7 "sparc/sparc.md"*)
      val STB = (fn {r, i, d, mem} => op := 8 (aggb (8, 8) ( $$ ("MEM", 8) (disp (r, i), mem)), bitslice 64 [(0, 7)] (fetch 64 (idaggr 64 ( $ ("GP", 64) d))))
                )

(*#line 93.7 "sparc/sparc.md"*)
      val STH = (fn {r, i, d, mem} => op := 16 (aggb (8, 16) ( $$ ("MEM", 8) (disp (r, i), mem)), bitslice 64 [(0, 15)] (fetch 64 (idaggr 64 ( $ ("GP", 64) d))))
                )

(*#line 94.7 "sparc/sparc.md"*)
      val ST = (fn {r, i, d, mem} => op := 32 (aggb (8, 32) ( $$ ("MEM", 8) (disp (r, i), mem)), bitslice 64 [(0, 31)] (fetch 64 (idaggr 64 ( $ ("GP", 64) d))))
               )

(*#line 95.7 "sparc/sparc.md"*)
      val STX = (fn {r, i, d, mem} => op := 64 (aggb (8, 64) ( $$ ("MEM", 8) (disp (r, i), mem)), bitslice 64 [(0, 63)] (fetch 64 (idaggr 64 ( $ ("GP", 64) d))))
                )

(*#line 100.7 "sparc/sparc.md"*)
      fun andn T372 (x, y) = andb T372 (x, notb T372 y)

(*#line 101.7 "sparc/sparc.md"*)
      fun orn T380 (x, y) = orb T380 (x, notb T380 y)

(*#line 102.7 "sparc/sparc.md"*)
      fun xnor T388 (x, y) = notb T388 (xorb T388 (x, y))

(*#line 107.7 "sparc/sparc.md"*)
      local
         val newOper = newOp "tadd"
      in
         fun tadd (x0, x1) = newOper [x0, x1]
      end
      local
         val newOper = newOp "taddtv"
      in
         fun taddtv (x0, x1) = newOper [x0, x1]
      end
      local
         val newOper = newOp "tsub"
      in
         fun tsub (x0, x1) = newOper [x0, x1]
      end
      local
         val newOper = newOp "tsubtv"
      in
         fun tsubtv (x0, x1) = newOper [x0, x1]
      end

(*#line 109.7 "sparc/sparc.md"*)
      fun multiply opc {r, i, d} = (op := 64 (idaggr 64 ( $ ("GP", 64) d), opc (fetch 64 (idaggr 64 ( $ ("GP", 64) r)),  % i))) || (op := 64 (idaggr 64 ( $ ("Y", 64) (intConst 0 0)),  ? 64))

(*#line 112.7 "sparc/sparc.md"*)
      fun multiplycc opc {r, i, d} = (multiply opc {r=r, i=i, d=d}) || (cc {})

(*#line 113.7 "sparc/sparc.md"*)
      fun divide opc {r, i, d} = op := 64 (idaggr 64 ( $ ("GP", 64) d), opc (fetch 64 (idaggr 64 ( $ ("GP", 64) r)),  % i))

(*#line 115.7 "sparc/sparc.md"*)
      fun dividecc opc {r, i, d} = (divide opc {r=r, i=i, d=d}) || (cc {})

(*#line 117.7 "sparc/sparc.md"*)
      fun logical opc {r, i, d} = op := 64 (idaggr 64 ( $ ("GP", 64) d), opc (fetch 64 (idaggr 64 ( $ ("GP", 64) r)),  % i))

(*#line 118.7 "sparc/sparc.md"*)
      fun logicalcc opc {r, i, d} = (op := 64 (idaggr 64 ( $ ("GP", 64) d), opc (fetch 64 (idaggr 64 ( $ ("GP", 64) r)),  % i))) || (cc {})

(*#line 119.7 "sparc/sparc.md"*)
      fun arith opc {r, i, d} = op := 64 (idaggr 64 ( $ ("GP", 64) d), opc (fetch 64 (idaggr 64 ( $ ("GP", 64) r)),  % i))

(*#line 120.7 "sparc/sparc.md"*)
      fun arithcc opc {r, i, d} = (op := 64 (idaggr 64 ( $ ("GP", 64) d), opc (fetch 64 (idaggr 64 ( $ ("GP", 64) r)),  % i))) || (cc {})

(*#line 122.7 "sparc/sparc.md"*)
      val li = (fn {i, d} => op := 64 (idaggr 64 ( $ ("GP", 64) d),  % i)
               )

(*#line 124.7 "sparc/sparc.md"*)
      val AND = logical (andb 64)
      and ANDN = logical (andn 64)
      and OR = logical (orb 64)
      and ORN = logical (orn 64)
      and XOR = logical (xorb 64)
      and XNOR = logical (xnor 64)

(*#line 127.7 "sparc/sparc.md"*)
      val ANDCC = logicalcc (andb 64)
      and ANDNCC = logicalcc (andn 64)
      and ORCC = logicalcc (orb 64)
      and ORNCC = logicalcc (orn 64)
      and XORCC = logicalcc (xorb 64)
      and XNORCC = logicalcc (xnor 64)

(*#line 130.7 "sparc/sparc.md"*)
      val ADD = arith (op + 64)
      and TADD = arith tadd
      and TADDTV = arith taddtv
      and SUB = arith (op - 64)
      and TSUB = arith tsub
      and TSUBTV = arith tsubtv

(*#line 133.7 "sparc/sparc.md"*)
      val ADDCC = arithcc (op + 64)
      and TADDCC = arithcc tadd
      and TADDTVCC = arithcc taddtv
      and SUBCC = arithcc (op - 64)
      and TSUBCC = arithcc tsub
      and TSUBTVCC = arithcc tsubtv

(*#line 136.7 "sparc/sparc.md"*)
      val UMUL = multiply (mulu 64)
      and SMUL = multiply (muls 64)

(*#line 137.7 "sparc/sparc.md"*)
      val UMULCC = multiplycc (mulu 64)
      and SMULCC = multiplycc (muls 64)

(*#line 138.7 "sparc/sparc.md"*)
      val UDIV = divide (divu 64)
      and SDIV = divide (divs 64)

(*#line 139.7 "sparc/sparc.md"*)
      val UDIVCC = dividecc (divu 64)
      and SDIVCC = dividecc (divs 64)

(*#line 141.7 "sparc/sparc.md"*)
      val MULX = arith (muls 64)
      and SDIVX = arith (divs 64)
      and UDIVX = arith (divu 64)

(*#line 142.7 "sparc/sparc.md"*)
      val SLL = logical (op << 64)
      and SRL = logical (op >> 64)
      and SRA = logical (op ~>> 64)

(*#line 143.7 "sparc/sparc.md"*)
      val SLLX = logical (op << 64)
      and SRLX = logical (op >> 64)
      and SRAX = logical (op ~>> 64)

(*#line 145.7 "sparc/sparc.md"*)
      local

(*#line 145.13 "sparc/sparc.md"*)
         fun xor T732 (a, b) = == T732 (a, b)

(*#line 147.13 "sparc/sparc.md"*)
         val N = == 1 (bitslice 64 [(23, 23)] (fetch 64 (idaggr 64 ( $ ("PSR", 64) (intConst 0 0)))), intConst 1 1)

(*#line 148.13 "sparc/sparc.md"*)
         val Z = == 1 (bitslice 64 [(22, 22)] (fetch 64 (idaggr 64 ( $ ("PSR", 64) (intConst 0 0)))), intConst 1 1)

(*#line 149.13 "sparc/sparc.md"*)
         val V = == 1 (bitslice 64 [(21, 21)] (fetch 64 (idaggr 64 ( $ ("PSR", 64) (intConst 0 0)))), intConst 1 1)

(*#line 150.13 "sparc/sparc.md"*)
         val C = == 1 (bitslice 64 [(20, 20)] (fetch 64 (idaggr 64 ( $ ("PSR", 64) (intConst 0 0)))), intConst 1 1)
      in

(*#line 151.11 "sparc/sparc.md"*)
         val A = True
         and E = Z
         and LE = Z
         and L = Z
         and LEU = Z
         and CS = C
         and NEG = N
         and VS = V
         and N = False
         and NE = not Z
         and G = Z
         and GE = Z
         and GU = Z
         and CC = not C
         and POS = not N
         and VC = not V
      end

(*#line 158.7 "sparc/sparc.md"*)
      val integer_tests = 
          let infix $$ fun x $$ y = y::x
          in  nil
             $$ VC
             $$ POS
             $$ CC
             $$ GU
             $$ GE
             $$ G
             $$ NE
             $$ A
             $$ VS
             $$ NEG
             $$ CS
             $$ LEU
             $$ L
             $$ LE
             $$ E
             $$ N
          end


(*#line 163.7 "sparc/sparc.md"*)
      fun branch status {label} = If (status, Jmp 64 ( %% label), Nop)

(*#line 164.7 "sparc/sparc.md"*)
      val [BN, BE, BLE, BL, BLEU, BCS, BNEG, BVS, BA, BNE, BG, BGE, BGU, BCC, BPOS, BVC] = map 16 branch integer_tests

(*#line 168.7 "sparc/sparc.md"*)
      val JMP = (fn {r, i} => Jmp 64 (disp (r, i))
                )

(*#line 171.7 "sparc/sparc.md"*)
      fun MOVicc icc {i, d} = If (icc, op := 64 (idaggr 64 ( $ ("GP", 64) d),  % i), Nop)

(*#line 172.7 "sparc/sparc.md"*)
      fun FMOVicc icc {r, d} = If (icc, op := 32 (idaggr 32 ( $ ("FP", 32) d), fetch 32 (idaggr 32 ( $ ("FP", 32) r))), Nop)

(*#line 174.7 "sparc/sparc.md"*)
      val MOVE = MOVicc E
      and MOVLE = MOVicc LE
      and MOVL = MOVicc L
      and MOVLEU = MOVicc LEU
      and MOVCS = MOVicc CS
      and MOVNEG = MOVicc NEG
      and MOVVS = MOVicc VS
      and MOVNE = MOVicc NE
      and MOVG = MOVicc G
      and MOVGE = MOVicc GE
      and MOVGU = MOVicc GU
      and MOVCC = MOVicc CC
      and MOVPOS = MOVicc POS
      and MOVVC = MOVicc VC

(*#line 180.7 "sparc/sparc.md"*)
      val FMOVE = FMOVicc E
      and FMOVLE = FMOVicc LE
      and FMOVL = FMOVicc L
      and FMOVLEU = FMOVicc LEU
      and FMOVCS = FMOVicc CS
      and FMOVNEG = FMOVicc NEG
      and FMOVVS = FMOVicc VS
      and FMOVNE = FMOVicc NE
      and FMOVG = FMOVicc G
      and FMOVGE = FMOVicc GE
      and FMOVGU = FMOVicc GU
      and FMOVCC = FMOVicc CC
      and FMOVPOS = FMOVicc POS
      and FMOVVC = FMOVicc VC

(*#line 187.7 "sparc/sparc.md"*)
      fun MOVR T914 rcc {r, i, d} = If (rcc (fetch 64 (idaggr 64 ( $ ("GP", 64) r)), intConst T914 0), op := 64 (idaggr 64 ( $ ("GP", 64) d),  % i), Nop)

(*#line 188.7 "sparc/sparc.md"*)
      val MOVRZ = MOVR 64 ( == 64)
      and MOVRLEZ = MOVR 64 (op <= 64)
      and MOVRLZ = MOVR 64 (op < 64)
      and MOVRNZ = MOVR 64 (op <> 64)
      and MOVRGZ = MOVR 64 (op > 64)
      and MOVRGEZ = MOVR 64 (op >= 64)

(*#line 192.7 "sparc/sparc.md"*)
      val LDF = (fn {r, i, d, mem} => op := 32 (idaggr 32 ( $ ("FP", 32) d), fetch 32 (aggb (8, 32) ( $$ ("MEM", 8) (disp (r, i), mem))))
                )

(*#line 193.7 "sparc/sparc.md"*)
      val LDDF = (fn {r, i, d, mem} => op := 32 (idaggr 32 ( $ ("FP", 32) d), fetch 32 (aggb (8, 32) ( $$ ("MEM", 8) (disp (r, i), mem))))
                 )

(*#line 194.7 "sparc/sparc.md"*)
      val LDQF = (fn {r, i, d, mem} => op := 32 (idaggr 32 ( $ ("FP", 32) d), fetch 32 (aggb (8, 32) ( $$ ("MEM", 8) (disp (r, i), mem))))
                 )

(*#line 195.7 "sparc/sparc.md"*)
      val STF = (fn {r, i, d, mem} => op := 32 (aggb (8, 32) ( $$ ("MEM", 8) (disp (r, i), mem)), fetch 32 (idaggr 32 ( $ ("FP", 32) d)))
                )

(*#line 196.7 "sparc/sparc.md"*)
      val STDF = (fn {r, i, d, mem} => op := 32 (aggb (8, 32) ( $$ ("MEM", 8) (disp (r, i), mem)), fetch 32 (idaggr 32 ( $ ("FP", 32) d)))
                 )

(*#line 198.7 "sparc/sparc.md"*)
      val LDFSR = (fn {r, i, mem} => op := 64 (idaggr 64 ( $ ("FSR", 64) (intConst 0 0)), fetch 64 (aggb (8, 64) ( $$ ("MEM", 8) (disp (r, i), mem))))
                  )

(*#line 199.7 "sparc/sparc.md"*)
      val LDXFSR = (fn {r, i, mem} => op := 64 (idaggr 64 ( $ ("FSR", 64) (intConst 0 0)), fetch 64 (aggb (8, 64) ( $$ ("MEM", 8) (disp (r, i), mem))))
                   )

(*#line 200.7 "sparc/sparc.md"*)
      val STFSR = (fn {r, i, mem} => op := 64 (aggb (8, 64) ( $$ ("MEM", 8) (disp (r, i), mem)), fetch 64 (idaggr 64 ( $ ("FSR", 64) (intConst 0 0))))
                  )

(*#line 203.7 "sparc/sparc.md"*)
      local
         val newOper = newOp "fitos"
      in
         fun fitos x0 = newOper [x0]
      end
      local
         val newOper = newOp "fitod"
      in
         fun fitod x0 = newOper [x0]
      end
      local
         val newOper = newOp "fitoq"
      in
         fun fitoq x0 = newOper [x0]
      end
      local
         val newOper = newOp "fstoi"
      in
         fun fstoi x0 = newOper [x0]
      end
      local
         val newOper = newOp "fdtoi"
      in
         fun fdtoi x0 = newOper [x0]
      end
      local
         val newOper = newOp "fqtoi"
      in
         fun fqtoi x0 = newOper [x0]
      end
      local
         val newOper = newOp "fstod"
      in
         fun fstod x0 = newOper [x0]
      end
      local
         val newOper = newOp "fstoq"
      in
         fun fstoq x0 = newOper [x0]
      end
      local
         val newOper = newOp "fdtos"
      in
         fun fdtos x0 = newOper [x0]
      end
      local
         val newOper = newOp "fdtoq"
      in
         fun fdtoq x0 = newOper [x0]
      end
      local
         val newOper = newOp "fqtos"
      in
         fun fqtos x0 = newOper [x0]
      end
      local
         val newOper = newOp "fqtod"
      in
         fun fqtod x0 = newOper [x0]
      end

(*#line 206.7 "sparc/sparc.md"*)
      fun fmovs x = x

(*#line 207.7 "sparc/sparc.md"*)
      fun fmovd x = x

(*#line 208.7 "sparc/sparc.md"*)
      fun fmovq x = x

(*#line 210.7 "sparc/sparc.md"*)
      fun funary opc {r, d} = op := 32 (idaggr 32 ( $ ("FP", 32) d), opc (fetch 32 (idaggr 32 ( $ ("FP", 32) r))))

(*#line 213.7 "sparc/sparc.md"*)
      val FiTOs = funary fitos
      and FiTOd = funary fitod
      and FiTOq = funary fitoq
      and FsTOi = funary fstoi
      and FdTOi = funary fdtoi
      and FqTOi = funary fqtoi
      and FsTOd = funary fstod
      and FsTOq = funary fstoq
      and FdTOs = funary fdtos
      and FdTOq = funary fdtoq
      and FqTOs = funary fqtos
      and FqTOd = funary fqtod
      and FMOVs = funary fmovs
      and FNEGs = funary (fneg 32)
      and FABSs = funary (fabs 32)
      and FMOVd = funary fmovd
      and FNEGd = funary (fneg 32)
      and FABSd = funary (fabs 32)
      and FMOVq = funary fmovq
      and FNEGq = funary (fneg 32)
      and FABSq = funary (fabs 32)
      and FSQRTs = funary (fsqrt 32)
      and FSQRTd = funary (fsqrt 32)
      and FSQRTq = funary (fsqrt 32)

(*#line 224.7 "sparc/sparc.md"*)
      fun fbinary opc {r1, r2, d} = op := 32 (idaggr 32 ( $ ("FP", 32) d), opc (fetch 32 (idaggr 32 ( $ ("FP", 32) r1)), fetch 32 (idaggr 32 ( $ ("FP", 32) r2))))

(*#line 225.7 "sparc/sparc.md"*)
      local
         val newOper = newOp "fsmuld"
      in
         fun fsmuld (x0, x1) = newOper [x0, x1]
      end
      local
         val newOper = newOp "fdmulq"
      in
         fun fdmulq (x0, x1) = newOper [x0, x1]
      end

(*#line 226.7 "sparc/sparc.md"*)
      val FADDs = fbinary (fadd 32)
      and FADDd = fbinary (fadd 32)
      and FADDq = fbinary (fadd 32)
      and FSUBs = fbinary (fsub 32)
      and FSUBd = fbinary (fsub 32)
      and FSUBq = fbinary (fsub 32)
      and FMULs = fbinary (fmul 32)
      and FMULd = fbinary (fmul 32)
      and FMULq = fbinary (fmul 32)
      and FsMULd = fbinary fsmuld
      and FdMULq = fbinary fdmulq
      and FDIVs = fbinary (fdiv 32)
      and FDIVd = fbinary (fdiv 32)
      and FDIVq = fbinary (fdiv 32)

(*#line 235.7 "sparc/sparc.md"*)
      local
         val newOper = newOp "Nan"
      in
         fun Nan x0 = newOper [x0]
      end

(*#line 236.7 "sparc/sparc.md"*)
      fun nan r = Nop

(*#line 237.7 "sparc/sparc.md"*)
      local
         val newOper = newOp "cmps"
      in
         fun cmps (x0, x1) = newOper [x0, x1]
      end
      local
         val newOper = newOp "cmpd"
      in
         fun cmpd (x0, x1) = newOper [x0, x1]
      end
      local
         val newOper = newOp "cmpq"
      in
         fun cmpq (x0, x1) = newOper [x0, x1]
      end

(*#line 238.7 "sparc/sparc.md"*)
      val FCMPs = (fn {r1, r2} => op := 64 (idaggr 64 ( $ ("FSR", 64) (intConst 0 0)), cmps (fetch 32 (idaggr 32 ( $ ("FP", 32) r1)), fetch 32 (idaggr 32 ( $ ("FP", 32) r2))))
                  )

(*#line 239.7 "sparc/sparc.md"*)
      val FCMPd = (fn {r1, r2} => op := 64 (idaggr 64 ( $ ("FSR", 64) (intConst 0 0)), cmpd (fetch 32 (idaggr 32 ( $ ("FP", 32) r1)), fetch 32 (idaggr 32 ( $ ("FP", 32) r2))))
                  )

(*#line 240.7 "sparc/sparc.md"*)
      val FCMPq = (fn {r1, r2} => op := 64 (idaggr 64 ( $ ("FSR", 64) (intConst 0 0)), cmpq (fetch 32 (idaggr 32 ( $ ("FP", 32) r1)), fetch 32 (idaggr 32 ( $ ("FP", 32) r2))))
                  )

(*#line 241.7 "sparc/sparc.md"*)
      val FCMPEs = (fn {r1, r2} => ((op := 64 (idaggr 64 ( $ ("FSR", 64) (intConst 0 0)), cmps (fetch 32 (idaggr 32 ( $ ("FP", 32) r1)), fetch 32 (idaggr 32 ( $ ("FP", 32) r2))))) || (nan r1)) || (nan r2)
                   )

(*#line 242.7 "sparc/sparc.md"*)
      val FCMPEd = (fn {r1, r2} => ((op := 64 (idaggr 64 ( $ ("FSR", 64) (intConst 0 0)), cmpd (fetch 32 (idaggr 32 ( $ ("FP", 32) r1)), fetch 32 (idaggr 32 ( $ ("FP", 32) r2))))) || (nan r1)) || (nan r2)
                   )

(*#line 243.7 "sparc/sparc.md"*)
      val FCMPEq = (fn {r1, r2} => ((op := 64 (idaggr 64 ( $ ("FSR", 64) (intConst 0 0)), cmpq (fetch 32 (idaggr 32 ( $ ("FP", 32) r1)), fetch 32 (idaggr 32 ( $ ("FP", 32) r2))))) || (nan r1)) || (nan r2)
                   )

(*#line 245.7 "sparc/sparc.md"*)
      local

(*#line 245.13 "sparc/sparc.md"*)
         val X = == 64 (fetch 64 (idaggr 64 ( $ ("FSR", 64) (intConst 0 0))), intConst 64 0)
      in

(*#line 246.11 "sparc/sparc.md"*)
         val floating_point_tests as [FN, FNE, FLG, FUL, FL, FUG, FG, FU, FA, FE, FUE, FGE, FUGE, FLE, FULE, FO] = 
             let infix $$ fun x $$ y = y::x
             in  nil
                $$ X
                $$ X
                $$ X
                $$ X
                $$ X
                $$ X
                $$ X
                $$ X
                $$ X
                $$ X
                $$ X
                $$ X
                $$ X
                $$ X
                $$ X
                $$ X
             end

      end

(*#line 253.7 "sparc/sparc.md"*)
      fun fbranch fcc {label} = If (fcc, Jmp 64 ( %% label), Nop)

(*#line 254.7 "sparc/sparc.md"*)
      val [FBN, FBNE, FBLG, FBUL, FBL, FBUG, FBG, FBU, FBA, FBE, FBUE, FBGE, FBUGE, FBLE, FBULE, FBO] = map 16 fbranch floating_point_tests

(*#line 259.7 "sparc/sparc.md"*)
      fun MOVfcc fcc {i, d} = If (fcc, op := 64 (idaggr 64 ( $ ("GP", 64) d),  % i), Nop)

(*#line 260.7 "sparc/sparc.md"*)
      fun FMOVfcc fcc {r, d} = If (fcc, op := 32 (idaggr 32 ( $ ("FP", 32) d), fetch 32 (idaggr 32 ( $ ("FP", 32) r))), Nop)

(*#line 262.7 "sparc/sparc.md"*)
      val [MOVN, MOVNE, MOVLG, MOVUL, MOVL, MOVUG, MOVG, MOVU, MOVA, MOVE, MOVUE, MOVGE, MOVUGE, MOVLE, MOVULE, MOVO] = map 16 MOVfcc floating_point_tests

(*#line 266.7 "sparc/sparc.md"*)
      val [FMOVN, FMOVNE, FMOVLG, FMOVUL, FMOVL, FMOVUG, FMOVG, FMOVU, FMOVA, FMOVE, FMOVUE, FMOVGE, FMOVUGE, FMOVLE, FMOVULE, FMOVO] = map 16 FMOVfcc floating_point_tests

(*#line 271.7 "sparc/sparc.md"*)
      fun Trap T1656 x = Jmp T1656 x

(*#line 272.7 "sparc/sparc.md"*)
      fun Ticc cc {r, i} = If (cc, Trap 64 (disp (r, i)), Nop)

(*#line 273.7 "sparc/sparc.md"*)
      fun Txcc cc {r, i} = If (cc, Trap 64 (disp (r, i)), Nop)

(*#line 275.7 "sparc/sparc.md"*)
      val [TICCBN, TICCBE, TICCBLE, TICCBL, TICCBLEU, TICCBCS, TICCBNEG, TICCBVS, TICCBA, TICCBNE, TICCBG, TICCBGE, TICCBGU, TICCBCC, TICCBPOS, TICCBVC] = map 16 Ticc integer_tests

(*#line 278.7 "sparc/sparc.md"*)
      val [TXCCBN, TXCCBE, TXCCBLE, TXCCBL, TXCCBLEU, TXCCBCS, TXCCBNEG, TXCCBVS, TXCCBA, TXCCBNE, TXCCBG, TXCCBGE, TXCCBGU, TXCCBCC, TXCCBPOS, TXCCBVC] = map 16 Txcc integer_tests

(*#line 283.7 "sparc/sparc.md"*)
      val JMP = (fn {r, i} => Jmp 64 (disp (r, i))
                )

(*#line 284.7 "sparc/sparc.md"*)
      val JMPL = (fn {r, i, d, defs, uses, mem} => (((Call 64 (disp (r, i))) || (op := 64 (idaggr 64 ( $ ("GP", 64) d),  ? 64))) || (op := 64 (idaggr 64 ( $ ("cellset", 0) defs), fetch 64 (idaggr 64 ( $ ("cellset", 0) uses))))) || (op := 8 (aggb (8, 8) ( $$ ("MEM", 8) ( ? 64, mem)), fetch 8 (aggb (8, 8) ( $$ ("MEM", 8) ( ? 64, mem)))))
                 )

(*#line 289.7 "sparc/sparc.md"*)
      val CALL = (fn {label, defs, uses, mem} => ((Call 64 ( %% label)) || (op := 64 (idaggr 64 ( $ ("cellset", 0) defs), fetch 64 (idaggr 64 ( $ ("cellset", 0) uses))))) || (op := 8 (aggb (8, 8) ( $$ ("MEM", 8) ( ? 64, mem)), fetch 8 (aggb (8, 8) ( $$ ("MEM", 8) ( ? 64, mem)))))
                 )

(*#line 293.7 "sparc/sparc.md"*)
      val RET = (fn {} => Ret
                )
   end
end

