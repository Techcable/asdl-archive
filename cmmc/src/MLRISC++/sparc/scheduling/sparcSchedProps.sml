(*
 * This file was automatically generated by MDGen (v2.0)
 * from the machine description file "sparc/sparc.md".
 *)


functor SparcSchedProps(structure Instr : SPARCINSTR
                        structure RegionProps : REGION_PROPERTIES
                        structure Asm   : INSTRUCTION_EMITTER where I = Instr
                          sharing RegionProps.Region = Instr.Region
                       ) : SCHEDULING_PROPERTIES =
struct
   structure I = Instr
   structure C = I.C
   
   type latency = int
   type time = int
   type architecture = string
   
   exception SparcStructuralHazard
   exception StructuralHazard = SparcStructuralHazard
   fun error msg = MLRiscErrorMsg.error("SparcSchedProps",msg)
   
   fun bug(msg,instr) =
   let val Asm.S.STREAM{emit, ...} = Asm.makeStream []
   in  emit (fn r => r) instr; error msg end
   
   val source = I.SOURCE{}
   val sink   = I.SINK{}
   
   structure A = DynArray
   type state = int
   type reservation_table = (state * I.instruction list) A.array
   fun newTableDefault{n, backward} = A.array(n,(0,[]))
   fun defUseDefault instr = let
          fun undefined () = bug ("defUseDefault", instr)
          fun getOpnd (opnd, rest) = 
              (
               case opnd of
               I.REG GP => GP::rest
             | _ => rest
              )
          fun mkSet set = map (fn r => (r,0)) set
          fun getRegionDef r = 
          let val (d,u) = RegionProps.writeTo r
          in  map (fn r => (r,~1)) d end
          fun getRegionUse r = RegionProps.readFrom r
          fun getCellSetDef (GP, FP, PSR) = (mkSet GP) @ ((mkSet FP) @ (mkSet PSR))
          fun getCellSetUse (GP, FP, PSR) = GP @ (FP @ PSR)
          fun query (I.LOAD{l, d, r, i, mem}) = 
              (
               case l of
               (I.LDSB | I.LDSH | I.LDUB | I.LDUH | I.LD | I.LDX) => ([(d, 1)], getOpnd (i, r::(getRegionUse mem)))
             | I.LDD => undefined ()
              )
            | query (I.STORE{s, d, r, i, mem}) = 
              (
               case s of
               (I.STB | I.STH | I.ST | I.STX) => (getRegionDef mem, getOpnd (i, [d, r]))
             | I.STD => undefined ()
              )
            | query (I.FLOAD{l, r, i, d, mem}) = 
              (
               case l of
               (I.LDF | I.LDDF | I.LDQF) => ([(d, 1)], getOpnd (i, r::(getRegionUse mem)))
             | (I.LDFSR | I.LDXFSR) => ([(66, 1)], getOpnd (i, r::(getRegionUse mem)))
              )
            | query (I.FSTORE{s, d, r, i, mem}) = 
              (
               case s of
               (I.STF | I.STDF) => (getRegionDef mem, getOpnd (i, [d, r]))
             | I.STFSR => (getRegionDef mem, getOpnd (i, [r, 66]))
              )
            | query (I.SETHI{i, d}) = ([(d, 0)], [])
            | query (I.ARITH{a, r, i, d}) = 
              (
               case (a, r) of
               (I.OR, 0) => ([(d, 0)], getOpnd (i, []))
             | _ => 
               (
                case a of
                (I.UMUL | I.UMULCC | I.SMUL | I.SMULCC) => ([(d, 0), (64, 0)], getOpnd (i, [r]))
              | 
                ( I.ANDCC |
                I.ANDNCC |
                I.ORCC |
                I.ORNCC |
                I.XORCC |
                I.XNORCC |
                I.ADDCC |
                I.TADDCC |
                I.TADDTVCC |
                I.SUBCC |
                I.TSUBCC |
                I.TSUBTVCC |
                I.UDIVCC |
                I.SDIVCC ) => ([(d, 0), (65, 0)], getOpnd (i, [r]))
              | 
                ( I.AND |
                I.ANDN |
                I.OR |
                I.ORN |
                I.XOR |
                I.XNOR |
                I.ADD |
                I.TADD |
                I.TADDTV |
                I.SUB |
                I.TSUB |
                I.TSUBTV |
                I.UDIV |
                I.SDIV |
                I.MULX |
                I.SDIVX |
                I.UDIVX ) => ([(d, 0)], getOpnd (i, [r]))
               )
              )
            | query (I.SHIFT{s, r, i, d}) = ([(d, 0)], getOpnd (i, [r]))
            | query (I.Bicc{b, a, label, nop}) = 
              (
               case b of
               (I.BN | I.BA) => ([], [])
             | 
               ( I.BE |
               I.BLE |
               I.BL |
               I.BLEU |
               I.BCS |
               I.BNEG |
               I.BVS |
               I.BNE |
               I.BG |
               I.BGE |
               I.BGU |
               I.BCC |
               I.BPOS |
               I.BVC ) => ([], [65])
              )
            | query (I.FBfcc{b, a, label, nop}) = ([], [66])
            | query (I.JMP{r, i, labs, nop}) = ([], getOpnd (i, [r]))
            | query (I.JMPL{r, i, d, defs, uses, nop, mem}) = ((d, 0)::((getCellSetDef defs) @ (getRegionDef mem)), getOpnd (i, r::((getCellSetUse uses) @ (getRegionUse mem))))
            | query (I.CALL{defs, uses, label, nop, mem}) = ((getCellSetDef defs) @ (getRegionDef mem), (getCellSetUse uses) @ (getRegionUse mem))
            | query (I.Ticc{t, cc, r, i}) = 
              (
               case (cc, t) of
               ((I.ICC, I.BN)|(I.XCC, I.BN)|(I.ICC, I.BA)|(I.XCC, I.BA)) => ([], getOpnd (i, [r]))
             | 
               ((I.ICC, I.BE)|
               (I.XCC, I.BE)|
               (I.ICC, I.BLE)|
               (I.XCC, I.BLE)|
               (I.ICC, I.BL)|
               (I.XCC, I.BL)|
               (I.ICC, I.BLEU)|
               (I.XCC, I.BLEU)|
               (I.ICC, I.BCS)|
               (I.XCC, I.BCS)|
               (I.ICC, I.BNEG)|
               (I.XCC, I.BNEG)|
               (I.ICC, I.BVS)|
               (I.XCC, I.BVS)|
               (I.ICC, I.BNE)|
               (I.XCC, I.BNE)|
               (I.ICC, I.BG)|
               (I.XCC, I.BG)|
               (I.ICC, I.BGE)|
               (I.XCC, I.BGE)|
               (I.ICC, I.BGU)|
               (I.XCC, I.BGU)|
               (I.ICC, I.BCC)|
               (I.XCC, I.BCC)|
               (I.ICC, I.BPOS)|
               (I.XCC, I.BPOS)|
               (I.ICC, I.BVC)|
               (I.XCC, I.BVC)) => ([], getOpnd (i, [r, 65]))
              )
            | query (I.FPop1{a, r, d}) = ([(d, 0)], [r])
            | query (I.FPop2{a, r1, r2, d}) = ([(d, 0)], [r1, r2])
            | query (I.FCMP{cmp, r1, r2, nop}) = ([(66, 1)], [r1, r2])
            | query (I.COPY{dst, src, impl, tmp}) = (mkSet dst, src)
            | query (I.FCOPY{dst, src, impl, tmp}) = (mkSet dst, src)
            | query (I.RDY{d}) = ([(d, 0)], [64])
            | query (I.WRY{r, i}) = ([(64, 0)], getOpnd (i, [r]))
            | query (I.RET{leaf, nop}) = ([], [])
            | query (I.ANNOTATION{i, a}) = query i
            | query _ = undefined ()
       in query instr
       end

   fun insertAfterDefault(rt, time, instr) = 
   let fun loop(t) = 
       let val (state, _) = A.sub(rt, t)
       in  if state >= 1 then loop(t+1) else t (* XXX *)
       end
       val index = loop(time)
       val (state, instrs) = A.sub(rt, index)
       val newState = state+1
       val newInstrs = instr::instrs
   in  A.update(rt, index, (newState, newInstrs)); time end
   fun insertBeforeDefault(rt, time, instr) = 
   let val index = ~time
       val (state, instrs) = A.sub(rt, index)
       val newState = state
       val newInstrs = instr::instrs
   in  A.update(rt, index, (newState, newInstrs)); time end
   fun linearizeDefault{table, backward} = 
     if backward then
        A.foldr (fn ((_,instrs),l) => List.revAppend(instrs,l)) [] table
     else
        A.foldl (fn ((_,instrs),l) => instrs @ l) [] table
   fun info arch = {newTable=newTableDefault, defUse=defUseDefault, insertAfter=insertAfterDefault, insertBefore=insertBeforeDefault, linearize=linearizeDefault}
   structure Shuffle = Shuffle(I)
   fun move{src=I.Direct rs,dst=I.Direct rd} =
        [I.COPY{src=[rs], dst=[rd], tmp=NONE, impl=ref NONE}]
   fun fmove{src=I.FDirect rs,dst=I.FDirect rd} =
        [I.FCOPY{src=[rs], dst=[rd], tmp=NONE, impl=ref NONE}]
   val shuffle = Shuffle.shuffle{mvInstr=move, ea=I.Direct}
   val shufflefp = Shuffle.shuffle{mvInstr=fmove, ea=I.FDirect}
   fun splitCopies regmap =
   let fun f(I.ANNOTATION{i,...}) = f i
         | f(I.COPY{src,dst,tmp,...}) =
             shuffle{regmap=regmap, tmp=tmp, src=src, dst=dst}
         | f(I.FCOPY{src,dst,tmp,...}) =
             shufflefp{regmap=regmap, tmp=tmp, src=src, dst=dst}
         | f i = [i]
   in  f end
end

