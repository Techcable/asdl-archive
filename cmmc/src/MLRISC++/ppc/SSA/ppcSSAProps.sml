(*
 * This file was automatically generated by MDGen (v2.0)
 * from the machine description file "ppc/ppc.md".
 *)


functor PPCSSAProps(structure Instr : PPCINSTR
                    structure RegionProps : REGION_PROPERTIES 
                    structure RTLProps : RTL_PROPERTIES where I = Instr
                    structure Asm : INSTRUCTION_EMITTER where I = Instr
                    structure OperandTable : OPERAND_TABLE where I = Instr
                      sharing RegionProps.Region = Instr.Region
                    val volatile : Instr.C.cell list
                    val pinnedDef  : Instr.C.cell list
                    val pinnedUse  : Instr.C.cell list
                    val fixedDef   : Instr.C.cell list
                    val fixedUse   : Instr.C.cell list
                   ) : SSA_PROPERTIES =
struct
   structure I        = Instr
   structure C        = I.C
   structure RTLProps = RTLProps
   structure RTL      = RTLProps.RTL
   structure T        = RTL.T
   structure OT       = OperandTable
   structure RP       = RegionProps
   
   datatype const = datatype OT.const
   
   fun error msg = MLRiscErrorMsg.error("PPCSSAProps",msg)
   
   fun bug(msg,instr) =
   let val Asm.S.STREAM{emit, ...} = Asm.makeStream []
   in  emit (fn r => r) instr; error msg end
   
   val volatile = volatile
   val pinnedDef = pinnedDef
   val pinnedUse = pinnedUse
   val fixedDef  = fixedDef
   val fixedUse  = fixedUse
   val source = I.SOURCE{}
   val sink   = I.SINK{}
   val phi    = I.PHI{}
   
   fun namingConstraints {instr, dst, src} = let
          fun undefined () = bug ("namingConstraints", instr)
          fun cellset(dstsrc,S,C) =
          let val S = C.cellsetToCells S
          in  List.revAppend(ListPair.zip(dstsrc,S),C) end
          fun query _ = undefined ()
       in query instr
       end

   fun rewriteOperands {const} {instr, dst, src} = let
          fun undefined () = bug ("rewriteOperands", instr)
          fun rwOpnd v =
          if v >= 0 then I.RegOp(v)
          else (case const v of
                 OT.OPERAND opnd => opnd
               | OT.IMMED i => I.ImmedOp(i)
               )
          fun query _ = undefined ()
       in query instr
       end

   fun copies cps =
   let fun f([],id,is,fd,fs) = (id,is,fd,fs)
         | f({kind,dst,src}::cps,id,is,fd,fs) =
           if dst=src then f(cps,id,is,fd,fs)
           else case kind of
                C.GP   => f(cps,dst::id,src::is,fd,fs)
             |  C.FP   => f(cps,id,is,dst::fd,src::fs)
             |  C.MEM  => f(cps,id,is,fd,fs)
             |  C.CTRL => f(cps,id,is,fd,fs)
             |  _      => error("copies: "^C.cellkindToString kind^
                                " dst="^C.toString kind dst^
                                " src="^C.toString kind src)
    val (id,is,fd,fs) = f(cps,[],[],[],[])
    val icopy = case id of
                  []  => []
                | [_] => [I.COPY{src=is,dst=id,impl=ref NONE,tmp=NONE}]
                | _   => [I.COPY{src=is,dst=id,impl=ref NONE,
                                 tmp=SOME(I.Direct(C.newReg()))}]
    val fcopy = case fd of
                  []  => []
                | [_] => [I.FCOPY{src=fs,dst=fd,impl=ref NONE,tmp=NONE}]
                | _   => [I.FCOPY{src=fs,dst=fd,impl=ref NONE,
                                  tmp=SOME(I.FDirect(C.newFreg()))}]
   in icopy @ fcopy end
   
   fun copy{instr=I.COPY{impl,tmp,...},dst=dst as [_],src} =
           I.COPY{impl=impl,tmp=NONE,dst=dst,src=src}
     | copy{instr=I.COPY{impl,tmp,...},dst,src} =
           I.COPY{impl=impl,tmp=tmp,dst=dst,src=src}
     | copy{instr=I.FCOPY{impl,tmp,...},dst=dst as [_],src} =
           I.FCOPY{impl=impl,tmp=NONE,dst=dst,src=src}
     | copy{instr=I.FCOPY{impl,tmp,...},dst,src} =
           I.FCOPY{impl=impl,tmp=tmp,dst=dst,src=src}
     | copy{instr=I.ANNOTATION{i,a},dst,src} =
           I.ANNOTATION{i=copy{instr=i,dst=dst,src=src},a=a}
     | copy{instr,...} = bug("copy",instr)

(*#line 730.9 "ppc/ppc.md"*)
   fun operand (ty, I.RegOp r) = T.REG (32, r)
     | operand (ty, I.ImmedOp i) = T.LI i
end

